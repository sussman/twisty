diff -urbw zplet-20060707/src/russotto/iff/IFFChunkNotFoundException.java twisty/src/russotto/iff/IFFChunkNotFoundException.java
--- zplet-20060707/src/russotto/iff/IFFChunkNotFoundException.java	2001-02-26 11:18:16.000000000 -0800
+++ twisty/src/russotto/iff/IFFChunkNotFoundException.java	2007-11-20 10:40:04.000000000 -0800
@@ -1,8 +1,17 @@
+/* This file was modified from the original source, please see the
+ * zplet.patch file included at the top of this source tree.
+ */
+
 package russotto.iff;
 
 public
 class IFFChunkNotFoundException extends Exception {
     /**
+	 * 
+	 */
+	private static final long serialVersionUID = -5761452412858846702L;
+
+	/**
      * Constructs an IFFChunkNotFoundException with no detail message.
      * A detail message is a String that describes this particular exception.
      */
diff -urbw zplet-20060707/src/russotto/iff/IFFFile.java twisty/src/russotto/iff/IFFFile.java
--- zplet-20060707/src/russotto/iff/IFFFile.java	2001-02-26 11:18:16.000000000 -0800
+++ twisty/src/russotto/iff/IFFFile.java	2008-10-17 21:23:41.000000000 -0700
@@ -1,32 +1,61 @@
+/* This file was modified from the original source, please see the
+ * zplet.patch file included at the top of this source tree.
+ */
+
 package russotto.iff;
 import java.io.*;
 import java.util.*;
 
+import com.google.twisty.io.Seekable;
+import com.google.twisty.io.SeekableFactory;
+
 public class IFFFile
-		extends RandomAccessFile
 {
-    protected Stack openchunks;
+	protected Stack<Long> openchunks;
+	protected final RandomAccessFile file;
+	protected final Seekable seeker;
     
     public IFFFile(String name, String mode) throws IOException
     {
-		super(name, mode);
-		openchunks = new Stack();
+		file = new RandomAccessFile(name, mode);
+		seeker = SeekableFactory.fromRandomAccessFile(file);
+		openchunks = new Stack<Long>();
     }
 
     public IFFFile(File file, String mode) throws IOException
     {
-		super(file, mode);
-		openchunks = new Stack();
+		this.file = new RandomAccessFile(file, mode);
+		seeker = SeekableFactory.fromRandomAccessFile(this.file);
+		openchunks = new Stack<Long>();
+	}
+	
+	public IFFFile(Seekable seeker) {
+		file = null;
+		this.seeker = seeker;
+		openchunks = new Stack<Long>();
     }
 
     public void chunkSeek(int offset) throws IOException
     {
-    	seek(((Long)openchunks.peek()).longValue() + 4 + offset);
+		seek((openchunks.peek()).longValue() + 4 + offset);
     }
     
     public int getChunkPointer() throws IOException
     {
-    	return (int)getFilePointer() - (int)((Long)openchunks.peek()).longValue() - 4;
+		return (int)getFilePointer() - (int)(openchunks.peek()).longValue() - 4;
+	}
+
+	public void close() throws IOException {
+		if (file != null)
+			file.close();
+	}
+
+	public long getFilePointer() throws IOException {
+		return seeker.getFilePointer();
+	}
+
+	public void seek(long pos) throws IOException {
+		seeker.seek(pos);
     }
 }
 
diff -urbw zplet-20060707/src/russotto/iff/IFFInputFile.java twisty/src/russotto/iff/IFFInputFile.java
--- zplet-20060707/src/russotto/iff/IFFInputFile.java	2001-02-26 11:18:16.000000000 -0800
+++ twisty/src/russotto/iff/IFFInputFile.java	2008-10-17 23:31:16.000000000 -0700
@@ -1,22 +1,57 @@
+/* This file was modified from the original source, please see the
+ * zplet.patch file included at the top of this source tree.
+ */
+
 package russotto.iff;
 import java.io.*;
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
 import java.util.*;
 
+import com.google.twisty.io.SeekableByteArrayInputStream;
+
 public class IFFInputFile
 		extends IFFFile
 {
-	private Stack openchunkends;
+	private Stack<Long> openchunkends;
+	private final DataInput input;
+	private final Method reader;
+	private final Object readerObject;
 	
-    public IFFInputFile(File file) throws IOException
+	public IFFInputFile(File f) throws IOException
     {
-		super(file, "r");
-		openchunkends = new Stack();
+		super(f, "r");
+		input = file;
+		readerObject = file;
+		reader = getReadMethod(readerObject);
+		openchunkends = new Stack<Long>();
     }
     
     public IFFInputFile(String name) throws IOException
     {
 		super(name, "r");
-		openchunkends = new Stack();
+		input = file;
+		readerObject = file;
+		reader = getReadMethod(readerObject);
+		openchunkends = new Stack<Long>();
+	}
+
+	public IFFInputFile(SeekableByteArrayInputStream bais) throws IOException {
+		super(bais);
+		input = new DataInputStream(bais);
+		readerObject = bais;
+		reader = getReadMethod(readerObject);
+		openchunkends = new Stack<Long>();
+	}
+
+	private static Method getReadMethod(Object o) {
+		try {
+			return o.getClass().getMethod("read", byte[].class, int.class, int.class);
+		} catch (SecurityException e) {
+			throw new RuntimeException(e);
+		} catch (NoSuchMethodException e) {
+			throw new RuntimeException(e);
+		}
     }
     
     public synchronized IFFChunkInfo readChunkInfo() throws IOException {
@@ -26,7 +61,7 @@
     	
     	read(chunktype, 0, 4);
     	chunkbegin = getFilePointer();
-    	result.chunktype = new String(chunktype, 0);
+		result.chunktype = new String(chunktype, "US-ASCII");
     	result.chunklength = readInt();
 		openchunks.push(new Long(chunkbegin));
 		openchunkends.push(new Long(getFilePointer() + result.chunklength));
@@ -37,12 +72,12 @@
     public synchronized IFFChunkInfo skipToChunk(String type) throws IOException, IFFChunkNotFoundException {
     	IFFChunkInfo chunkinfo;
 
-		if (getFilePointer() >= ((Long)openchunkends.peek()).longValue())
+		if (getFilePointer() >= (openchunkends.peek()).longValue())
 			throw new IFFChunkNotFoundException("Chunk " + type + " not found at current level");
 		chunkinfo = readChunkInfo();
 		while (!chunkinfo.chunktype.equals(type)) {
 			closeChunk();
-			if (getFilePointer() >= ((Long)openchunkends.peek()).longValue())
+			if (getFilePointer() >= (openchunkends.peek()).longValue())
 				throw new IFFChunkNotFoundException("Chunk " + type + " not found at current level");
 			chunkinfo = readChunkInfo();
 		}
@@ -60,13 +95,13 @@
      	else {
 //     		throw new Exception("That's not a FORM!");
      	}
-     	return new String(subtype, 0);
+		return new String(subtype, "US-ASCII");
      }
 
     public synchronized void closeChunk() throws IOException {
     	long chunkend;
     	
-    	chunkend = (((Long)openchunkends.pop()).longValue() + 1) & ~1L;
+		chunkend = ((openchunkends.pop()).longValue() + 1) & ~1L;
     	openchunks.pop();
     	// doing the seek last ensures exceptions leave stacks consistent
     	seek(chunkend);
@@ -85,4 +120,31 @@
 		}
 		super.close();
     }
+
+	/**
+	 * Uses reflection to read from the underlying input. We do it this way
+	 * because ByteArrayInputStream and RandomAccessFile share identical
+	 * read() methods but not a common interface.
+	 */
+	public int read(byte[] buffer, int offset, int count) throws IOException {
+		try {
+			Object r = reader.invoke(readerObject, buffer, offset, count);
+			if (r instanceof Integer)
+				return ((Integer) r).intValue();
+			throw new RuntimeException("Incorrect return type from read()");
+		} catch (IllegalArgumentException e) {
+			throw new RuntimeException(e);
+		} catch (IllegalAccessException e) {
+			throw new RuntimeException(e);
+		} catch (InvocationTargetException e) {
+			if (e.getCause() instanceof IOException)
+				throw (IOException) e.getCause();
+			throw new RuntimeException(e);
+		}
+	}
+
+	// Selectively wrap DataInput
+	public byte readByte() throws IOException { return input.readByte(); }
+	public short readShort() throws IOException { return input.readShort(); }
+	public int readInt() throws IOException { return input.readInt(); }
 }
diff -urbw zplet-20060707/src/russotto/iff/IFFOutputFile.java twisty/src/russotto/iff/IFFOutputFile.java
--- zplet-20060707/src/russotto/iff/IFFOutputFile.java	2001-02-26 11:18:16.000000000 -0800
+++ twisty/src/russotto/iff/IFFOutputFile.java	2008-10-17 00:27:37.000000000 -0700
@@ -1,13 +1,21 @@
+/* This file was modified from the original source, please see the
+ * zplet.patch file included at the top of this source tree.
+ */
+
 package russotto.iff;
 import java.io.*;
-import java.util.*;
+
+import com.google.twisty.io.SeekableByteArrayOutputStream;
 
 public class IFFOutputFile
 		extends IFFFile
 {
+	private final DataOutput output;
+
     public IFFOutputFile(File file) throws IOException
     {
 		super(file, "rw");
+		output = this.file;
     }
     
     public IFFOutputFile(File file, String type) throws IOException
@@ -20,6 +28,7 @@
     public IFFOutputFile(String name) throws IOException
     {
 		super(name, "rw");
+		output = this.file;
     }
     
     public IFFOutputFile(String name, String type) throws IOException
@@ -29,10 +38,20 @@
 		write(getOSType(type), 0, 4);
     }
 
+	public IFFOutputFile(SeekableByteArrayOutputStream baos, String type) throws IOException {
+		super(baos);
+		output = new DataOutputStream(baos);
+		openChunk("FORM");
+		write(getOSType(type), 0, 4);
+	}
+
     private byte[] getOSType(String s)
     {
+		byte[] bytes = s.getBytes();
+		if (bytes.length == 4)
+			return bytes;
 		byte result[] = new byte[4];
-		s.getBytes(0, 4, result, 0);
+		System.arraycopy(bytes, 0, result, 0, 4);
 		return result;
     }
 
@@ -65,4 +84,12 @@
 		    closeChunk();
 		super.close();
     }
+
+	public void writeByte(int val) throws IOException { output.writeByte(val); }
+	public void writeShort(int val) throws IOException { output.writeShort(val); }
+	public void writeInt(int val) throws IOException { output.writeInt(val); }
+	public void write(byte[] buffer) throws IOException { output.write(buffer); }
+	public void write(byte[] buffer, int offset, int count) throws IOException {
+		output.write(buffer, offset, count);
+	}
 }
Only in zplet-20060707/src/russotto/zplet: .DS_Store
diff -urbw zplet-20060707/src/russotto/zplet/ZColor.java twisty/src/russotto/zplet/ZColor.java
--- zplet-20060707/src/russotto/zplet/ZColor.java	2001-02-26 11:18:16.000000000 -0800
+++ twisty/src/russotto/zplet/ZColor.java	2007-11-20 10:40:08.000000000 -0800
@@ -1,3 +1,6 @@
+/* This file was modified from the original source, please see the
+ * zplet.patch file included at the top of this source tree.
+ */
 /* Zplet, a Z-Machine interpreter in Java */
 /* Copyright 1996,2001 Matthew T. Russotto */
 /* As of 23 February 2001, this code is open source and covered by the */
@@ -5,11 +8,7 @@
 
 package russotto.zplet;
 
-import java.util.*;
-import java.awt.*;
-import java.net.*;
-import java.io.*;
-import java.applet.Applet;
+import com.google.twisty.zplet.Color;
 
 public class ZColor {
 	public final static int Z_CURRENT = 0;
Only in zplet-20060707/src/russotto/zplet: ZJApp.java
Only in zplet-20060707/src/russotto/zplet: Zplet.java
Only in zplet-20060707/src/russotto/zplet/screenmodel: .DS_Store
diff -urbw zplet-20060707/src/russotto/zplet/screenmodel/NoSuchKeyException.java twisty/src/russotto/zplet/screenmodel/NoSuchKeyException.java
--- zplet-20060707/src/russotto/zplet/screenmodel/NoSuchKeyException.java	2001-02-26 11:18:16.000000000 -0800
+++ twisty/src/russotto/zplet/screenmodel/NoSuchKeyException.java	2007-11-20 10:40:05.000000000 -0800
@@ -1,3 +1,6 @@
+/* This file was modified from the original source, please see the
+ * zplet.patch file included at the top of this source tree.
+ */
 /* Zplet, a Z-Machine interpreter in Java */
 /* Copyright 1996,2001 Matthew T. Russotto */
 /* As of 23 February 2001, this code is open source and covered by the */
@@ -5,13 +8,12 @@
 
 package russotto.zplet.screenmodel;
 
-import java.util.*;
-import java.awt.*;
-import java.net.*;
-import java.io.*;
-import java.applet.Applet;
-
 class NoSuchKeyException extends Exception {
+	/**
+	 * 
+	 */
+	private static final long serialVersionUID = 159728078977125275L;
+
 	public NoSuchKeyException() {
 		super();
 	}
Only in zplet-20060707/src/russotto/zplet/screenmodel: SyncVector.java
Only in zplet-20060707/src/russotto/zplet/screenmodel: ZCursor.java
diff -urbw zplet-20060707/src/russotto/zplet/screenmodel/ZScreen.java twisty/src/russotto/zplet/screenmodel/ZScreen.java
--- zplet-20060707/src/russotto/zplet/screenmodel/ZScreen.java	2006-07-07 17:12:38.000000000 -0700
+++ twisty/src/russotto/zplet/screenmodel/ZScreen.java	2008-10-18 12:39:48.000000000 -0700
@@ -1,3 +1,6 @@
+/* This file was modified from the original source, please see the
+ * zplet.patch file included at the top of this source tree.
+ */
 /* Zplet, a Z-Machine interpreter in Java */
 /* Copyright 1996,2001 Matthew T. Russotto */
 /* As of 23 February 2001, this code is open source and covered by the */
@@ -5,33 +8,33 @@
 
 package russotto.zplet.screenmodel;
 
-import java.util.*;
-import java.awt.*;
-import java.net.*;
-import java.io.*;
-import java.applet.Applet;
+import java.util.LinkedList;
+import java.util.NoSuchElementException;
+import java.util.Vector;
+import java.util.concurrent.LinkedBlockingQueue;
+
 import russotto.zplet.ZColor;
+import android.os.Handler;
+import android.util.Log;
 
-public class ZScreen extends Canvas {
-		int lines;
-		int chars; /* in fixed font */
-		Font fixedfont;
-		FontMetrics fixedmetrics;
-		Font variablefont;
-		Font graphicsfont;
-		SyncVector inputcodes;
-		Vector bufferedcodes;
+import com.google.twisty.zplet.Event;
+import com.google.twisty.zplet.Font;
+import com.google.twisty.zplet.ZMachineException;
+import com.google.twisty.zplet.ZMachineInterrupted;
+import com.google.twisty.zplet.ZViewOutput;
+
+public class ZScreen {
+	private final ZViewOutput[] views;
+	LinkedBlockingQueue<Short> inputcodes;
+	LinkedList<Short> bufferedcodes;
 		boolean bufferdone;
 		ZWindow inputwindow;
-		ZCursor inputcursor;
-		int zforeground = ZColor.Z_BLACK;
-		int zbackground = ZColor.Z_WHITE;
-		Image backing_store;
-		Graphics g_store;
-		Color zbcolor;
+	Font fixedfont;
+	Font variablefont;
+	Handler dialog_handler;
+	int default_foreground;
+	int default_background;
 		boolean hasscrolled = false;
-		public final static String DEFAULT_FONT_FAMILY = "Courier";
-		public final static int DEFAULT_FONT_SIZE = 12;
 		final static char accent_table[] = {
 			 	'\u00e4',			/* a-umlaut */
 			 	'\u00f6',			/* o-umlaut */
@@ -103,65 +106,29 @@
 			 	'\u00a1',			/* inverse-! */
 			 	'\u00bf',			/* inverse-? */
 	     };
+	private static final String TAG = "ZScreen";
 
-
-		public ZScreen() {
-		    this (DEFAULT_FONT_FAMILY, DEFAULT_FONT_SIZE);
+	public ZScreen(ZViewOutput[] twistyViews, Handler handler,
+			String fixedFontFamily, String variableFontFamily, int font_size) {
+		views = twistyViews;
+		dialog_handler = handler;
+		setFixedFont(fixedFontFamily, font_size);
+		setVariableFont(fixedFontFamily, font_size);
+
+		inputcodes = new LinkedBlockingQueue<Short>();
+		bufferedcodes = new LinkedList<Short>();
+		default_foreground = ZColor.Z_BLACK;
+		default_background = ZColor.Z_WHITE;
 		}
 
-		public ZScreen( String font_family, int font_size ) {
-				Dimension mysize = size();
-				
-				this.setFixedFont (font_family, font_size);
-				fixedmetrics = getFontMetrics(fixedfont);
-				chars = mysize.width / fixedmetrics.charWidth(' ');
-				lines = mysize.height / fixedmetrics.getHeight();
-
-				inputcodes = new SyncVector();
-				bufferedcodes = new Vector();
-				inputcursor = new ZCursor(this);
-				setForeground(ZColor.getcolor(zforeground));
-				setBackground(ZColor.getcolor(zbackground));
+	public ZViewOutput getView(int index) {
+		return views[index];
 		}
 		
 		protected boolean isterminator(int key) {
 				return ((key == 10) || (key == 13));
 		}
 
-/*		public boolean mouseDown(Event evt, int x, int y) {
-//				System.err.print("mouseDown ");
-				if (inside(x,y)) {
-						requestFocus();
-//						System.err.println("inside");
-						return true;
-				}
-				else {
-						System.err.println("outside");
-						return false;
-				}
-		}
-*/
-
-		public boolean mouseEnter(Event evt, int x, int y)
-		{
-				requestFocus();
-				return true; /* it's MY event */
-		}
-
-/*
-		public boolean gotFocus(Event evt, Object what)
-		{
-				System.err.println("ZScreen got focus");
-				return false;
-		}
-		
-		public boolean lostFocus(Event evt, Object what)
-		{
-				System.err.println("ZScreen lost focus");
-				return false;
-		}
-*/
-
 		static char zascii_to_unicode(short zascii) {
 				if ((zascii >= 32) && (zascii <= 126)) /* normal ascii */
 					return (char)zascii;
@@ -176,7 +143,7 @@
 					return '?';
 				}
 				else {
-					System.err.println("Illegal character code: " + zascii);
+			Log.e(TAG, "Illegal character code: " + zascii);
 					return '?';
 				}
 		}
@@ -227,19 +194,17 @@
 		}
 		
 		public boolean keyDown(Event e, int key) {
-
 				short code;
 				
-				/* TODO: e, key to code */
 				try {
 					if (e.id == Event.KEY_PRESS)
 						code = unicode_to_zascii((char)key);
 					else /* if (e.action == Event.KEY_ACTION) */
 						code = fkey_to_zascii(key);
-					inputcodes.syncAddElement(new Integer(code));
+			inputcodes.offer(new Short(code));
 				}
 				catch (NoSuchKeyException excpt) {
-					System.err.println(excpt);
+			Log.w(TAG, "No such key in keyDown: " + key);
 				}
 				return true;
 		}
@@ -250,49 +215,30 @@
 		}
 
 		public short read_code() {
-				Integer thecode = null;
-				
-				while (thecode == null) {
-						thecode = (Integer)inputcodes.syncPopFirstElement();
+		try {
+			return inputcodes.take().shortValue();
+		} catch (InterruptedException e) {
+			throw new ZMachineInterrupted();
 				}
-				return (short)thecode.intValue();
 		}
 		
 		public short read_buffered_code() { /* should really be synched */
-						   Integer thecode;
-				int incode;
-				short result;
-				int cw, ch;
+		Short thecode;
+		short incode;
 
 				inputwindow.flush();
-				cw = fixedmetrics.charWidth(' ');
-				ch = fixedmetrics.getHeight();
-
-//				inputcursor.setGraphics(getGraphics());
-//				inputcursor.setcolors(getForeground(), getBackground());
-				inputcursor.setcolors(getForeground(), zbcolor);
-				inputcursor.size(cw, ch);
 
 				while (!bufferdone) {
 						inputwindow.flush();
-						inputcursor.move((inputwindow.getLeft() + inputwindow.cursorx) * cw,
-														 (inputwindow.getTop() + inputwindow.cursory) * ch);
-						inputcursor.show();
-						Toolkit.getDefaultToolkit().sync();
+			inputwindow.showCursor(true);
 						incode = read_code();
-//						inputcursor.setGraphics(getGraphics());
-						inputcursor.hide();
+			inputwindow.showCursor(false);
 						if ((incode == 8) || (incode == 127)) {
 								try {
-										thecode = (Integer)bufferedcodes.lastElement();
-										bufferedcodes.removeElementAt(bufferedcodes.size() - 1);
+					thecode = bufferedcodes.removeLast();
 										inputwindow.flush();
-										inputwindow.movecursor(inputwindow.cursorx - 1, 
-																				   inputwindow.cursory);
-										inputwindow.printzascii((short)' ');
+					inputwindow.backspace();
 										inputwindow.flush();
-										inputwindow.movecursor(inputwindow.cursorx - 1, 
-																				   inputwindow.cursory);
 								}
 								catch (NoSuchElementException booga) {
 										/* ignore */
@@ -305,49 +251,19 @@
 												inputwindow.newline();
 								}
 								else {
-										inputwindow.printzascii((short)incode);
+					inputwindow.printzascii(incode);
 										inputwindow.flush();
 								}
-								bufferedcodes.addElement(new Integer(incode));
+				bufferedcodes.addLast(new Short(incode));
 						}
 				}
-				thecode = (Integer)bufferedcodes.firstElement();
-				bufferedcodes.removeElementAt(0);
+		thecode = bufferedcodes.removeFirst();
 				if (bufferedcodes.isEmpty()) {
 						bufferdone = false;
 				}
 				return (short)(thecode.intValue());
 		}
 
-		public int getlines() {
-				return lines;
-		}
-		
-		public int getchars() {
-				return chars;
-		}
-
-		public synchronized void reshape(int x, int y, int width, int height) {
-				int lines;
-				int i;
-				char newbuffer[][];
-
-				if ((width >= 0) && (height >= 0)) {
-						lines = height / fixedmetrics.getHeight();
-						chars = width / fixedmetrics.charWidth(' ');
-						backing_store = createImage(width, height);
-						g_store = backing_store.getGraphics();
-						g_store.setColor(zbcolor);
-						g_store.fillRect(0, 0, width, height);
-						this.lines = lines;
-				}
-				super.reshape(x, y, width, height);
-		}
-		
-		public int charwidth() { /* character width of the fixed font */
-				return fixedmetrics.charWidth(' ');
-		}
-
 		/**
 		 * Set the main font for the game.
 		 * The Font Family can be any legal font name. However use of a
@@ -358,179 +274,70 @@
 		 * @param font_family   a Font Family sting (i.e. "Courier").
 		 * @param font_size     the point size of the font (int).
 		 */ 
-		public synchronized void
-		setFixedFont( String font_family, int font_size )
-		{
-		    if (font_size <= 0)
+	public synchronized void setFixedFont( String font_family, int font_size )
 		    {
-			font_size = this.DEFAULT_FONT_SIZE;
-		    }
 		    this.fixedfont = new Font(font_family, Font.PLAIN, font_size);
 		}
 
+	public synchronized void setVariableFont( String font_family, int font_size )
+	{
+		this.variablefont = new Font(font_family, Font.PLAIN, font_size);
+	}
+
 		/**
 		 * Get the main font for the game.
-		 * @return  a java.awt.Font object.
 		 */
-		public synchronized Font
-		getFixedFont( )
+	public synchronized Font getFixedFont( )
 		{
 		    return this.fixedfont;
 		}
 
-		public synchronized void settext(int y, int x, char newtext[],
-																		 int offset, int length)
-		{
-				settext(y,x,newtext,offset,length,false, fixedfont);
-		}
-
-		public synchronized void settext(int y, int x, char newtext[],
-																		 int offset, int length, boolean reverse,
-																		 Font textfont) {
-				int i;
-				char newbuffer[];
-				Graphics g;
-
-				try {
-						g_store.setFont(textfont);
-						drawtext(g_store, y, x, newtext, offset, length, reverse);
-						if (!hasscrolled) {
-								g = getGraphics();
-								g.setFont(textfont);
-								drawtext(g, y, x, newtext, offset, length, reverse);
-						}
-				}
-				catch (NullPointerException booga) {
-						System.err.println("No graphics in settext");
-				}
-		}
-
-		protected synchronized void drawtext(Graphics g, int y, int x, char newtext[], int offset, int length, boolean reverse) {
-				int tw, th;
-				int tx, ty;
-				
-				tw = length * fixedmetrics.charWidth(' ');
-				th = fixedmetrics.getHeight();
-				tx = x * fixedmetrics.charWidth(' ');
-				ty = th * (y + 1) - fixedmetrics.getDescent();
-				if (reverse) {
-						g.setColor(getForeground());
-						g.fillRect(tx, th * y, tw, th);
-//						g.setColor(getBackground());
-						g.setColor(zbcolor);
-				}
-				else {
-//						g.setColor(getBackground());
-						g.setColor(zbcolor);
-						g.fillRect(tx, th * y, tw, th);
-						g.setColor(getForeground());
-				}
-				g.drawChars(newtext, offset, length, tx, ty);
-				g.setColor(getForeground());
-		}
-		
-		public synchronized void scrollLines(int top, int height, int lines) {
-				int j;
-				Graphics g;
-				int texttop;
-
-//				System.err.println("scrollLines top height lines "
-//												   + top + " "
-//												   + height + " "
-//												   + lines + " ");
-				try {
-						texttop = top * fixedmetrics.getHeight();
-						g_store.copyArea(0, texttop + lines * fixedmetrics.getHeight(),
-														 size().width, (height - lines) * fixedmetrics.getHeight(),
-														 0, -lines * fixedmetrics.getHeight());
-//						g_store.setColor(getBackground());
-						g_store.setColor(zbcolor);
-						g_store.fillRect(0, texttop + ((height-1) * fixedmetrics.getHeight()),
-														 size().width, fixedmetrics.getHeight());
-//						Toolkit.getDefaultToolkit().sync();
-				}
-				catch (NullPointerException booga) {
-						System.err.println("No graphics in scrollLines");
-				}
-				repaint();
-				hasscrolled = true;
-		}
-		
-		public synchronized void paint(Graphics g) {
-				int y;
-				int ypixels;
-
-//				super.paint(g);
-//				System.err.println("paint");
-				g.drawImage(backing_store, 0, 0, null);
-				inputcursor.redraw(g);
-				hasscrolled = false;
-		}
-
-//		public void repaint(long tm, int x, int y, int width, int height) {
-//				System.err.println("repaint: " + tm + " " + x + " " + y + " " + width + " " + height);
-//				super.repaint(tm,x,y,width,height);
-//		}
-
-		public void update(Graphics g) {
-//				System.err.println("update");
-				g.setColor(getForeground());
-				paint(g);
-		}
-
-		public void clear() {
-				Dimension mysize = size();
-
-				try {
-//						g_store.setColor(getBackground());
-						g_store.setColor(zbcolor);
-						g_store.fillRect(0, 0,
-														 mysize.width, mysize.height);
-				}
-				catch (NullPointerException booga) {
-						System.err.println("No graphics in clear");
-				}
-				repaint();
+	public Handler getDialogHandler() {
+		// return Twisty's main dialog handler
+		return dialog_handler;
 		}
 
 		public int getZForeground() 
 		{
-				return zforeground;
+		return default_foreground;
 		}
 		
 		public int getZBackground() 
 		{
-				return zbackground;
+		return default_background;
 		}
 		
-		public void setZForeground(int zcolor)
-		{
-				zforeground = zcolor;
-				setForeground(ZColor.getcolor(zcolor));
+	public void clearInputQueues() {
+		bufferedcodes.clear();
+		inputcodes.clear();
 		}
 		
-		public void setZBackground(int zcolor)
-		{
-				zbackground = zcolor;
-//				setBackground(ZColor.getcolor(zcolor)); Yucky side effects
-				zbcolor = ZColor.getcolor(zcolor);
+	public void clear() {
+		for (ZViewOutput v : views) {
+			v.clear();
+		}
 		}
 		
-		public Frame getFrame() {
-			Component cursor;
-			
-			cursor = this;
-			while (!(cursor instanceof Frame))
-				cursor = cursor.getParent();
-				
-			return (Frame)cursor;
+	/**
+	 * Used for the ZMachine header only.
+	 * @return some fictitious number
+	 */
+	public int getchars() {
+		return 64;
 		}
 		
-		public Dimension minimumSize() {
-				return new Dimension(100,100);
+	/**
+	 * Used for the ZMachine header only.
+	 * @return some fictitious number
+	 */
+	public int getlines() {
+		return 20;
 		}
 
-		public Dimension preferredSize() {
-				return new Dimension(500,500);
+	public void onZmFinished(ZMachineException e) {
+		for (ZViewOutput v : views) {
+			v.onZmFinished(e);
+		}
+		views[0].tellOwnerZmFinished(e);
 		}
 }
diff -urbw zplet-20060707/src/russotto/zplet/screenmodel/ZStatus.java twisty/src/russotto/zplet/screenmodel/ZStatus.java
--- zplet-20060707/src/russotto/zplet/screenmodel/ZStatus.java	2001-02-26 11:18:16.000000000 -0800
+++ twisty/src/russotto/zplet/screenmodel/ZStatus.java	2007-11-20 10:40:05.000000000 -0800
@@ -1,3 +1,6 @@
+/* This file was modified from the original source, please see the
+ * zplet.patch file included at the top of this source tree.
+ */
 /* Zplet, a Z-Machine interpreter in Java */
 /* Copyright 1996,2001 Matthew T. Russotto */
 /* As of 23 February 2001, this code is open source and covered by the */
@@ -5,13 +8,9 @@
 
 package russotto.zplet.screenmodel;
 
-import java.util.*;
-import java.awt.*;
-import java.net.*;
-import java.io.*;
-import java.applet.Applet;
+import com.google.twisty.zplet.Label;
 
-public class ZStatus extends Panel {
+public class ZStatus {
 		 boolean timegame;
 		 boolean initialized;
 		 boolean chronograph;
@@ -23,12 +22,9 @@
 		 Label Right;
 		 Label Left;
 		
-		 public ZStatus() {
-				 setLayout(new BorderLayout());
-				 Right = new Label();
-				 add("East", Right);
-				 Left = new Label();
-				 add("West", Left);
+		 public ZStatus(Label left, Label right) {
+				 Right = right;
+				 Left = left;
 				 chronograph = false;
 		 }
 
@@ -81,7 +77,7 @@
 				 layout();
 				 repaint();
 		 }
-		
+	/*	
 		 public Dimension minimumSize() {
 				 return new Dimension(100,10);
 		 }
@@ -89,6 +85,13 @@
 		 public Dimension preferredSize() {
 				 return new Dimension(500,20);
 		 }
+		 */
+		 
+		 private void layout() {
+		 }
+		 
+		 private void repaint() {
+		 }
  }
 
 
diff -urbw zplet-20060707/src/russotto/zplet/screenmodel/ZWindow.java twisty/src/russotto/zplet/screenmodel/ZWindow.java
--- zplet-20060707/src/russotto/zplet/screenmodel/ZWindow.java	2001-02-26 11:18:16.000000000 -0800
+++ twisty/src/russotto/zplet/screenmodel/ZWindow.java	2008-10-15 18:08:47.000000000 -0700
@@ -1,3 +1,6 @@
+/* This file was modified from the original source, please see the
+ * zplet.patch file included at the top of this source tree.
+ */
 /* Zplet, a Z-Machine interpreter in Java */
 /* Copyright 1996,2001 Matthew T. Russotto */
 /* As of 23 February 2001, this code is open source and covered by the */
@@ -5,19 +8,17 @@
 
 package russotto.zplet.screenmodel;
 
-import java.util.*;
-import java.awt.*;
-import java.net.*;
-import java.io.*;
-import java.applet.Applet;
 import russotto.zplet.ZColor;
 
+import com.google.twisty.zplet.Font;
+import com.google.twisty.zplet.ZViewOutput;
+
 public class ZWindow {
-		 final static int ROMAN = 0;
-		 final static int REVERSE = 1;
-		 final static int BOLD = 2;
-		 final static int ITALIC = 4;
-		 final static int FIXED = 8;
+	public final static int ROMAN = 0;
+	public final static int REVERSE = 1;
+	public final static int BOLD = 2;
+	public final static int ITALIC = 4;
+	public final static int FIXED = 8;
 
 		 final static char FIRST_STYLE = '\u8000';
 		 final static char BUF_ROMAN = (char)(FIRST_STYLE + ROMAN);
@@ -39,67 +40,35 @@
 		 final static char BUF_FIXED_FONT = '\u8013';
 		 final static char LAST_FONT = '\u8013';
 
-		 ZScreen myscreen;
-		 int top, left, width, height;
-		 int cursorx, cursory;
+	final ZViewOutput myview;
+	final ZScreen myscreen;
 		 boolean buffer, wrap, scroll, transcriptmode;
-		 int curzfont = NORMAL_FONT;
-		 int curzstyle = ROMAN;
+	int curzfont = FIXED_FONT;
+	int curzstyle = FIXED;
 		 Font curfont;
-		 String linebuffer;
-		 int line_counter;
+	StringBuilder linebuffer;
 		 int zforeground, zbackground;
-		 int residual;
 
-		 public ZWindow(ZScreen screen) {
-				 top = 0;
-				 left = 0;
-				 width = 10;
-				 height = 10;
-				 cursorx = 0;
-				 cursory = 0;
-				 line_counter = 0;
-				 residual = 0;
+	public ZWindow(ZScreen screen, int index) {
 				 myscreen = screen;
-				 curfont = screen.fixedfont;
+		myview = screen.getView(index);
+		curfont = new Font("", 0, 0);
 				 buffer = true;
 				 wrap = true;
 				 scroll = true;
 				 transcriptmode = true;
-				 linebuffer = "";
-				 zforeground = screen.zforeground;
-				 zbackground = screen.zbackground;
-		 }
-
-		 public void reset_line_count() {
-				 line_counter = 0;
-		 }
-
-		 void count_line() {
-				 line_counter++;
-		 }
-		
-		 void check_for_more() {
-				 String more  = "[MORE]";
-				 String blank = "         ";
-
-				 if (line_counter >= (height-1)) {
-						 myscreen.settext(top + cursory, left, more.toCharArray(), 0, more.length(), true, myscreen.fixedfont);
-						 myscreen.read_code();
-						 myscreen.settext(top + cursory, left, blank.toCharArray(), 0, blank.length(), false, myscreen.fixedfont);
-						 line_counter = 0;
-				 }
-				
+		linebuffer = new StringBuilder();
+		zforeground = screen.getZForeground();
+		zbackground = screen.getZBackground();
 		 }
 		
+	/**
+	 * if arg = 1: erase from cursor to EOL in current window;
+	 * else: do nothing.
+	 */
 		 public void erase_line(short arg) {
-				char spaces[] = new char[width];
-				short i;
-				
-				for (i = 0; i < width; i++)
-					spaces[i] = ' ';
 				if (arg == 1)
-					myscreen.settext(cursory, left + cursorx, spaces, 0, width - cursorx);
+			myview.eraseToEOL();
 		 }
 		
 		 public void setbuffermode(boolean buffermode)
@@ -115,7 +84,7 @@
 				 if (buffer) {
 						 flush();
 				 }
-				 wrap = wrapmode;
+		myview.setWrappable(wrapmode);
 		 }
 
 		 public void set_transcripting(boolean transcriptmode)
@@ -133,99 +102,42 @@
 				 scroll = newscroll;
 		 }
 
+	/** Moves this window onscreen to the requested position */
 		 public void moveto(int newleft, int newtop)
 		 {
-				 left = newleft;
-				 top = newtop;
+		myview.moveto(newleft, newtop);
 		 }
 
-		 public void resize (int newwidth, int newheight)
-		 {
-		     //		     System.err.println("resize: " + newwidth + " " + newheight );
-				 width = newwidth;
-				 height = newheight;
-				 if ((cursorx >= width) || (cursory >= height)) {
-						 movecursor_noflush(0,0);
-				 }
-		 }
-
-		 public int getLeft() {
-				 return left;
-		 }
-
-		 public int getTop() {
-				 return top;
-		 }
-
-		 public int getWidth() {
-				 return width;
-		 }
-
-		 public int getHeight() {
-				 return height;
-		 }
-
-		 public int getlines() {
-				 return height;
-		 }
-
-		 public int getchars() {
-				 return width;
-		 }
-
-		 public int getx() {
-				 return cursorx;
-		 }
-
-		 public int gety() {
-				 return cursory;
-		 }
-
-		 void movecursor_noflush(int x, int y)
-		 {
-				 cursorx = x;
-				 cursory = y;
-		 }
-
-		 public void movecursor(int x, int y)
+	public void movecursor(int pos)
 		 {
 				 flush();
-				 cursorx = x;
-				 cursory = y;
+		myview.moveCursor(pos);
 		 }
 		 
 		 public void printzascii(short ascii) {
-				 short zascii[] = new short[1];
-
-				 zascii[0] = ascii;
-				 printzascii(zascii);
+		printzascii(new short[] { ascii });
 		 }
 
 		 public void printzascii(short ascii[]) {
-				 /* short because the Z-machine can put out 10-bit codes */
-				 char unicode[];
-				 int i;
+		// short because the Z-machine can put out 10-bit codes
+		StringBuffer sb = new StringBuffer(ascii.length);
 				
-				 unicode = new char[ascii.length];
-
-				 for (i = 0; i < unicode.length; i++) {
-						 unicode[i] = ZScreen.zascii_to_unicode(ascii[i]);
+		for (short c : ascii) {
+			sb.append(ZScreen.zascii_to_unicode(c));
 				 }
 
 				 if (buffer) {
-						 bufferchars(unicode);
-				 }
-				 else {
-						 drawchars(unicode,0, unicode.length);
+			bufferString(sb.toString());
+		} else {
+			drawchars(sb);
 				 }
 		 }
 
 		 public void flush() {
-		 		residual = charsWidth(linebuffer.toCharArray(), 0, linebuffer.length());
-				drawstring(linebuffer);
-				linebuffer = "";
-//				System.err.println();
-//				System.err.println("linebuffer.length() = " + linebuffer.length());
+		if (linebuffer.length() > 0) {
+			drawchars(linebuffer);
+			linebuffer.setLength(0);
+		}
 		 }
  
 		 public void newline() {
@@ -233,78 +145,26 @@
 		 }
 
 		 protected void newline(boolean flushbuffer) {
-				 if (myscreen.zforeground != zforeground)
-						 myscreen.setZForeground(zforeground);
-				 if (myscreen.zbackground != zbackground)
-						 myscreen.setZBackground(zbackground);
-
-				 if (flushbuffer)
+		if (flushbuffer) {
+			myview.setColors(zforeground, zbackground);
 						 flush();
-						 
-				 residual = 0;
-
-				 if (cursory == height-1) {
-						 if (scroll)
-								 myscreen.scrollLines(top, height, 1);
-						 movecursor_noflush(0, cursory);
 				 }
-				 else {
-						 movecursor_noflush(0, cursory+1);
+		myview.newline();
+		if (scroll) {
+			myview.autoScroll();
 				 }
-				 count_line();
-//				 System.err.println();
 		 }
 
-		 public synchronized void bufferchars(char chars[]) {
-				 int last;
-				 int space;
-				 String printstring;
-
-//				 linebuffer = linebuffer + chars;
-				 linebuffer = new StringBuffer(linebuffer).append(chars).toString();
-
-				 if (wrap) {
-						 last = linebuffer.length();
-						 while ((residual + charsWidth(linebuffer.toCharArray(), 0, last))
-								 > (myscreen.size().width)) {
-								 space = linebuffer.lastIndexOf(' ', last);
-								 if (space == -1) {
-										 while ((residual + charsWidth(linebuffer.toCharArray(), 0, last)) > 
-														(width * myscreen.charwidth()))
-												 last--;
-										 drawchars(linebuffer.toCharArray(), 0, last);
-										 linebuffer = linebuffer.substring(last);
-										 newline(false);
-										 last = linebuffer.length();
-								 }
-								 else if ((residual + charsWidth(linebuffer.toCharArray(), 0, space)) <=
-												  (myscreen.size().width)) {
-										 printstring = linebuffer.substring(0, space);
-										 drawstring(printstring);
-										 while ((space < linebuffer.length())
-												 && (linebuffer.charAt(space) == ' ')) {
-												 space++;
-										 }
-										 linebuffer = linebuffer.substring(space);
-										 last = linebuffer.length();
-										 newline(false);
-								 }
-								 else
-										 last = space-1;
-						 }
+	public void bufferString(String s) {
+		bufferchars(s.toCharArray());
 				}
+
+	public synchronized void bufferchars(char chars[]) {
+		linebuffer.append(chars);
 		 }
 
 		 public void clear() {
-				 int i;
-				 char spaces[] = new char[width];
-
-				 for (i = 0; i < width; i++)
-						 spaces[i] = ' ';
-				
-				 for (i = top; i < top + height; i++) {
-						 myscreen.settext(i, left, spaces, 0, width);
-				 }
+		myview.clear();
 		 }
 
 		 private void calculate_font()
@@ -312,8 +172,10 @@
 				 Font basefont;
 				 int style = Font.PLAIN;
 
+		if ((curzstyle & FIXED) != 0)
 				 basefont = myscreen.fixedfont;
-
+		else
+			basefont = myscreen.variablefont;
 				 if ((curzstyle & BOLD) != 0)
 						 style |= Font.BOLD;
 				 if ((curzstyle & ITALIC) != 0)
@@ -323,7 +185,6 @@
 		 }
 
 		 public void set_color(int foreground, int background) {
-//			System.err.println("fg = " + foreground + ", bg = " + background);
 			flush();
 			if (foreground != ZColor.Z_CURRENT)
 				 zforeground = foreground;
@@ -362,6 +223,10 @@
 				 }
 		 }
 
+	private void drawchars(CharSequence cs) {
+		drawchars(cs.toString().toCharArray(), 0, cs.length());
+	}
+
 		 public void drawchars(char chars[], int offset, int length) {
 				 int firstchar;
 				 int runlength;
@@ -372,13 +237,11 @@
 //												  length + " " + top + " " + left + " " +
 //												  cursory + " " + cursorx);
 				 if (length != 0) {
-						 if (myscreen.zforeground != zforeground)
-								 myscreen.setZForeground(zforeground);
-						 if (myscreen.zbackground != zbackground)
-								 myscreen.setZBackground(zbackground);
+			myview.setColors(zforeground, zbackground);
 
-						 if (scroll && (cursorx == 0))
-								 check_for_more();
+			if (scroll) {
+				myview.autoScroll();
+			}
 						
 						 firstchar = offset;
 						 runlength = 0;
@@ -389,27 +252,52 @@
 												 break;
 										 }
 								 }
-								 myscreen.settext(top + cursory, left + cursorx, chars, 
+				myview.output(chars, 
 																  firstchar, runlength,
 																  (curzstyle & REVERSE) == REVERSE,
 																  curfont);
 								 parse_control(control);
 								 control = 0;
 								 firstchar += runlength + 1;
-								 cursorx += runlength;
 								 runlength = 0;
 						 }
 //				 System.err.print(new String(chars, offset, length));
 				 }
 		 }
 
-		 public void drawstring(String text)
-		 {
-				 drawchars(text.toCharArray(), 0, text.length());
+	/** backspace: move cursor left, erase intervening character  */
+	public void backspace() {
+		myview.backspace();
 		 }
 
-		 public int charsWidth(char line[], int offset, int length) {
-				 return myscreen.charwidth() * length;
+	public void reset_line_count() {
+		myview.resetAutoScroll();
 		 }
+
+	/** Called by v5+ to get cursor position */
+	public int getx() {
+		return myview.getPosX();
+	}
+
+	/** Called by v5+ to get cursor position */
+	public int gety() {
+		return myview.getPosY();
+	}
+
+	/** Called by v5+ to set cursor position */
+	public void movecursor(int x, int y) {
+		myview.moveCursor(y, x); 
+	}
+
+	/** show or hide the cursor */
+	public void showCursor(boolean show) {
+		myview.showCursor(show);
+	}
+
+	/** Called by zmachine to request a specific window size */
+	public void resize(int columns, int rows) {
+		myview.resize(columns, rows);
+	}
+
  }
 
diff -urbw zplet-20060707/src/russotto/zplet/zmachine/ZDictionary.java twisty/src/russotto/zplet/zmachine/ZDictionary.java
--- zplet-20060707/src/russotto/zplet/zmachine/ZDictionary.java	2001-02-26 11:18:16.000000000 -0800
+++ twisty/src/russotto/zplet/zmachine/ZDictionary.java	2007-11-20 10:40:08.000000000 -0800
@@ -1,3 +1,6 @@
+/* This file was modified from the original source, please see the
+ * zplet.patch file included at the top of this source tree.
+ */
 /* Zplet, a Z-Machine interpreter in Java */
 /* Copyright 1996,2001 Matthew T. Russotto */
 /* As of 23 February 2001, this code is open source and covered by the */
@@ -5,11 +8,6 @@
 
 package russotto.zplet.zmachine;
 
-import java.util.*;
-import java.awt.*;
-import java.net.*;
-import java.io.*;
-import java.applet.Applet;
 
 public abstract class ZDictionary
 {
diff -urbw zplet-20060707/src/russotto/zplet/zmachine/ZFrameBound.java twisty/src/russotto/zplet/zmachine/ZFrameBound.java
--- zplet-20060707/src/russotto/zplet/zmachine/ZFrameBound.java	2001-02-26 11:18:16.000000000 -0800
+++ twisty/src/russotto/zplet/zmachine/ZFrameBound.java	2008-10-20 10:35:05.000000000 -0700
@@ -1,3 +1,6 @@
+/* This file was modified from the original source, please see the
+ * zplet.patch file included at the top of this source tree.
+ */
 /* Zplet, a Z-Machine interpreter in Java */
 /* Copyright 1996,2001 Matthew T. Russotto */
 /* As of 23 February 2001, this code is open source and covered by the */
@@ -9,10 +12,17 @@
 public class ZFrameBound
 {
 	private boolean store;
+	public static ZFrameBound FALSE = new ZFrameBound(false);
+	public static ZFrameBound TRUE = new ZFrameBound(true);
 	
-	public ZFrameBound(boolean store) {
+	private ZFrameBound(boolean store) {
 		this.store = store;
 	}
+
+	public static ZFrameBound get(boolean store) {
+		return store ? TRUE : FALSE;
+	}
+
 	public boolean isstore() {
 		return store;
 	}
diff -urbw zplet-20060707/src/russotto/zplet/zmachine/ZHeader.java twisty/src/russotto/zplet/zmachine/ZHeader.java
--- zplet-20060707/src/russotto/zplet/zmachine/ZHeader.java	2001-02-26 11:18:16.000000000 -0800
+++ twisty/src/russotto/zplet/zmachine/ZHeader.java	2007-11-20 10:40:08.000000000 -0800
@@ -1,3 +1,6 @@
+/* This file was modified from the original source, please see the
+ * zplet.patch file included at the top of this source tree.
+ */
 /* Zplet, a Z-Machine interpreter in Java */
 /* Copyright 1996,2001 Matthew T. Russotto */
 /* As of 23 February 2001, this code is open source and covered by the */
@@ -5,12 +8,6 @@
 
 package russotto.zplet.zmachine;
 
-import java.util.*;
-import java.awt.*;
-import java.net.*;
-import java.io.*;
-import java.applet.Applet;
-import russotto.iff.*;
 
 public abstract class ZHeader {
 	protected byte memory_image[];
diff -urbw zplet-20060707/src/russotto/zplet/zmachine/ZInstruction.java twisty/src/russotto/zplet/zmachine/ZInstruction.java
--- zplet-20060707/src/russotto/zplet/zmachine/ZInstruction.java	2001-02-26 11:18:16.000000000 -0800
+++ twisty/src/russotto/zplet/zmachine/ZInstruction.java	2008-10-20 10:35:23.000000000 -0700
@@ -1,3 +1,6 @@
+/* This file was modified from the original source, please see the
+ * zplet.patch file included at the top of this source tree.
+ */
 /* Zplet, a Z-Machine interpreter in Java */
 /* Copyright 1996,2001 Matthew T. Russotto */
 /* As of 23 February 2001, this code is open source and covered by the */
@@ -5,11 +8,7 @@
 
 package russotto.zplet.zmachine;
 
-import java.util.*;
-import java.awt.*;
-import java.net.*;
-import java.io.*;
-import java.applet.Applet;
+import android.util.Log;
 import russotto.zplet.zmachine.state.ZState;
 
 public class ZInstruction {
@@ -94,6 +93,7 @@
 
 	protected final static int LOWER_WINDOW = 0;
 	protected final static int UPPER_WINDOW = 1;
+	private static final String TAG = "ZInstruction";
 
 	protected int opnum;
 	protected int count;
@@ -197,19 +197,19 @@
 
 					while (optypebytes-- != 0) {
 								optype = (optypes & 0xC0)>>6;
-								if (optype == zm.OP_OMITTED)
+								if (optype == ZMachine.OP_OMITTED)
 									break;
 								operands[count++] = zm.get_operand(optype);
 								optype = (optypes & 0x30)>>4;
-								if (optype == zm.OP_OMITTED)
+								if (optype == ZMachine.OP_OMITTED)
 									break;
 								operands[count++] = zm.get_operand(optype);
 								optype = (optypes & 0x0C)>>2;
-								if (optype == zm.OP_OMITTED)
+								if (optype == ZMachine.OP_OMITTED)
 									break;
 								operands[count++] = zm.get_operand(optype);
 								optype = (optypes & 0x03);
-								if (optype == zm.OP_OMITTED)
+								if (optype == ZMachine.OP_OMITTED)
 									break;
 								operands[count++] = zm.get_operand(optype);
 								optypes = optypes2;
@@ -218,7 +218,7 @@
 
 				case 0x80: /* short form */
 					optype = (opcode&0x30) >> 4;
-					if (optype == zm.OP_OMITTED) { /* 0OP */
+					if (optype == ZMachine.OP_OMITTED) { /* 0OP */
 								opnum = opcode;
 								count = 0;
 					}
@@ -263,7 +263,7 @@
 	{
 				short result;
 
-				//				System.err.println("Executing instruction " + opnum);
+				zm.logInstruction(this);
 				switch (opnum) {
 				case OP_JE:
 					result = op_je();
@@ -882,7 +882,7 @@
 
 	protected short op_save()
 	{
-				if ((new ZState(zm)).disk_save(zm.screen.getFrame(), save_pc))
+				if ((new ZState(zm)).disk_save(zm.screen, save_pc))
 					return ZSAVE_SUCCESS;
 				return ZFALSE;
 	}
@@ -892,20 +892,9 @@
 				ZState restore_state;
 				
 				restore_state = new ZState(zm);
-				if (restore_state.restore_from_disk(zm.screen.getFrame())) {
+				if (restore_state.restore_from_disk(zm.screen)) {
 					zm.restore(restore_state);
 					decode_second_half();
-					
-//					branchoffset = zm.get_code_byte();
-//					branchtype = (branchoffset&0x80) != 0;
-//					if ((branchoffset & 0x40) != 0) /* positive 6-bit number */
-//								branchoffset &= 0x3F;
-//					else if ((branchoffset & 0x20) != 0) /* negative 14-bit number */
-//								branchoffset = (short)(0xC000 |
-//																	   ((branchoffset << 8) |
-//																				(((short)zm.get_code_byte()) & 0xFF)));
-//					else /* positive 14-bit number */
-//								branchoffset = (short)(((branchoffset&0x3F) << 8) | (((short)zm.get_code_byte())&0xFF));
 					return ZRESTORE_SUCCESS;
 				}
 				return ZFALSE;
@@ -934,28 +923,8 @@
 
 	protected short op_quit()
 	{
-				zm.print_ascii_char((short)'*');
-				zm.print_ascii_char((short)'*');
-				zm.print_ascii_char((short)'*');
-				zm.print_ascii_char((short)'E');
-				zm.print_ascii_char((short)'N');
-				zm.print_ascii_char((short)'D');
-				zm.print_ascii_char((short)' ');
-				zm.print_ascii_char((short)'O');
-				zm.print_ascii_char((short)'F');
-				zm.print_ascii_char((short)' ');
-				zm.print_ascii_char((short)'S');
-				zm.print_ascii_char((short)'E');
-				zm.print_ascii_char((short)'S');
-				zm.print_ascii_char((short)'S');
-				zm.print_ascii_char((short)'I');
-				zm.print_ascii_char((short)'O');
-				zm.print_ascii_char((short)'N');
-				zm.print_ascii_char((short)'*');
-				zm.print_ascii_char((short)'*');
-				zm.print_ascii_char((short)'*');
-				zm.print_ascii_char((short)13);
-				zm.stop();
+		zm.print_ascii_string("[[ Game has ended ]]");
+		zm.quit();
 				return ZFALSE;
 	}
 
@@ -978,10 +947,10 @@
 				filesize = zm.header.file_length();
 				if ((filesize > zm.memory_image.length) ||
 					(zm.header.checksum() != zm.checksum)) {
-					System.err.println("VERIFY failed: ");
-					System.err.println("\texpected\tactual");
-					System.err.println("length\t"+filesize+"\t"+zm.memory_image.length);
-					System.err.println("checksum\t" 
+					Log.e(TAG, "VERIFY failed: ");
+					Log.e(TAG, "\texpected\tactual");
+					Log.e(TAG, "length\t"+filesize+"\t"+zm.memory_image.length);
+					Log.e(TAG, "checksum\t" 
 													   + Integer.toString(zm.header.checksum()&0xFFFF, 16)
 													   + "\t"+ Integer.toString(zm.checksum,16));
 					return ZFALSE;
@@ -1014,7 +983,7 @@
 					zm.set_variable(storevar, ZFALSE);
 				}
 				else {
-					zm.zstack.push(new ZFrameBound(isstore()));
+					zm.zstack.push(ZFrameBound.get(isstore()));
 					zm.zstack.push(new Integer(storevar));
 					zm.zstack.push(new Integer(zm.pc));
 					zm.zstack.push(zm.locals);
@@ -1148,27 +1117,15 @@
 
 	protected void split_screen(int lines)
 	{
-				int cx, cy;
-
 				zm.window[UPPER_WINDOW].flush();
 				zm.window[LOWER_WINDOW].flush();
 //				System.err.println("split screen " + lines);
-				cx = zm.window[LOWER_WINDOW].getx();
-				cy = zm.window[LOWER_WINDOW].gety() + zm.window[UPPER_WINDOW].getlines();
-				cy -= lines;
-				if (cy < 0)
-						cy = 0;
-//				System.err.println("cx cy" + cx + cy);
 				zm.window[LOWER_WINDOW].moveto(0,lines);
 				zm.window[UPPER_WINDOW].moveto(0,0);
-				zm.window[LOWER_WINDOW].resize(zm.screen.getchars(),
-																	   zm.screen.getlines() - lines);
+				// TODO: tedious cursor position calculation?
+				zm.window[UPPER_WINDOW].movecursor(0, 0);
+				zm.window[LOWER_WINDOW].resize(zm.screen.getchars(), -1);
 				zm.window[UPPER_WINDOW].resize(zm.screen.getchars(),lines);
-				if (cy >= (zm.screen.getlines() - lines)) {
-					cy = zm.screen.getlines() - lines - 1;
-				}
-				zm.window[LOWER_WINDOW].movecursor(cx, cy);
-//				System.err.println("cx cy" + cx + cy);
 	}
 
 	protected short op_split_window()
@@ -1219,7 +1176,7 @@
 				return ZNOTDONE;
 	}
 
-	protected void setupbs() {
+	protected static void setupbs() {
 	/* Sets up store and branch instructions */
 		branch[OP_JE] = true;
 		branch[OP_JL] = true;
diff -urbw zplet-20060707/src/russotto/zplet/zmachine/ZMachine.java twisty/src/russotto/zplet/zmachine/ZMachine.java
--- zplet-20060707/src/russotto/zplet/zmachine/ZMachine.java	2001-02-26 11:18:16.000000000 -0800
+++ twisty/src/russotto/zplet/zmachine/ZMachine.java	2008-10-19 23:42:43.000000000 -0700
@@ -1,3 +1,6 @@
+/* This file was modified from the original source, please see the
+ * zplet.patch file included at the top of this source tree.
+ */
 /* Zplet, a Z-Machine interpreter in Java */
 /* Copyright 1996,2001 Matthew T. Russotto */
 /* As of 23 February 2001, this code is open source and covered by the */
@@ -5,15 +8,23 @@
 
 package russotto.zplet.zmachine;
 
-import java.util.*;
-import java.awt.*;
-import java.net.*;
-import java.io.*;
-import java.applet.Applet;
-import russotto.zplet.screenmodel.*;
+import java.util.EmptyStackException;
+import java.util.LinkedList;
+import java.util.Random;
+import java.util.Stack;
+
+import android.util.Log;
+
+import com.google.twisty.zplet.ZMachineException;
+import com.google.twisty.zplet.ZMachineInterrupted;
+
+import russotto.zplet.screenmodel.ZScreen;
+import russotto.zplet.screenmodel.ZStatus;
+import russotto.zplet.screenmodel.ZWindow;
 import russotto.zplet.zmachine.state.ZState;
 
-public abstract class ZMachine extends Thread {
+public abstract class ZMachine {
+	private final Thread thread;
 	public ZWindow current_window;
 	public int pc;
 	public ZWindow window[];
@@ -24,7 +35,7 @@
 	public ZState restart_state;
 	protected ZStatus status_line;
 	public byte memory_image[];
-	public Stack zstack;
+	public Stack<Object> zstack;
 	public Random zrandom;
 	protected int globals;
 	public short locals[];
@@ -39,20 +50,51 @@
 	protected ZInstruction zi;
 	protected boolean status_redirect;
 	protected String status_location;
+	public boolean zmLog;
+	private StringBuffer zmLogString;
+	public CircularList<String> zmLogEntries;
 
 	protected final String A2 = "0123456789.,!?_#\'\"/\\-:()";
+	private InterruptState aborting;
 
 	public final static int OP_LARGE = 0;
 	public final static int OP_SMALL = 1;
 	public final static int OP_VARIABLE = 2;
 	public final static int OP_OMITTED = 3;
+	private static final String TAG = "ZMachine";
+	private static final String ZMLOG = "zmlog";
+
+	/*
+	 * UNSTARTED -start-> RUNNING -quit-------------> FINISHED
+	 *                    ^ | |                      /
+	 *                    |  \ \-abort-> ABORTING ->/
+	 *              RESUMING  \
+	 *                    ^    \-pause-> PAUSING
+	 *                    |               |
+	 *                 resume-- PAUSED <-/
+	 */
+	enum InterruptState {
+		UNSTARTED,
+		RUNNING,
+		ABORTING,
+		PAUSING,
+		PAUSED,
+		RESUMING,
+		FINISHED
+	}
 	
 	public ZMachine(ZScreen screen, ZStatus status_line, byte [] memory_image) {
+		thread = new Thread() {
+			@Override
+			public void run() {
+				runZM();
+			}
+		};
 				this.screen = screen;
 				this.status_line = status_line;
 				this.memory_image = memory_image;
 				locals = new short[0];
-				zstack = new Stack();
+		zstack = new Stack<Object>();
 				restart_state = new ZState(this);
 				restart_state.save_current();
 				zrandom = new Random(); /* starts in "random" mode */
@@ -60,6 +102,10 @@
 				outputs = new boolean[5];
 				outputs[1] = true;
 				alphabet = 0;
+		zmLog = false;
+		zmLogString = new StringBuffer();
+		zmLogEntries = new CircularList<String>(1000);
+		aborting = InterruptState.UNSTARTED;
 	}
 
 	public abstract void update_status_line();
@@ -102,6 +148,15 @@
 
 	public void print_ascii_char(short ch) {
 				int nchars;
+		if (zmLog) {
+			if (ch >= 20 && ch <= 127) {
+				zmLogString.append((char) ch);
+			} else {
+				zmLogString.append('<')
+				.append(Integer.toHexString(ch))
+				.append('>');
+			}	
+		}
 				if (status_redirect) {
 					status_location += (char)ch;
 				}
@@ -128,11 +183,14 @@
 					}
 					outputs[2] = header.transcripting();
 					if (outputs[2] && current_window.transcripting()) {
+				// TODO: android: send transcript somewhere
+				/*
 								if ((ch == 13) || (ch == 10)) {
 									System.out.println();
 								}					
 								else
 									System.out.print((char)ch);
+				*/
 					}
 				}
 	}
@@ -159,7 +217,7 @@
 					}
 					else if ((ch >= (int)'A') && (ch <= (int)'Z')) {
 								/* encode upper as lower.  Legal? */
-								System.err.println("Tried to encode uppercase dictionary word");
+				Log.e(TAG, "Tried to encode uppercase dictionary word");
 								zchars[zi] = ch - (int)'A' + 6;
 								if ((++zi) == (nwords*3))
 									break;
@@ -290,6 +348,7 @@
 				int zseq;
 				int i;
 
+		zmLogString.setLength(0);
 				nbytes = 0;
 				build_ascii = 0;
 				alphabet = 0;
@@ -306,38 +365,141 @@
 					nbytes+=2;
 				}
 				while ((zseq & 0x8000) == 0);
+		logPrintedString();
 				return nbytes;
 	}
 
 	public void start() {
+		changeState(InterruptState.RUNNING);
 				screen.clear();
 				restart();
 				header.set_transcripting(false);
-				super.start();
+		thread.start();
 	}
 
-	public void run()
-	{
+	public void join() throws InterruptedException {
+		thread.join();
+	}
+	
+	public abstract String[] getOpnames();
+	
+	/**
+	 * Block until the state is anything but other
+	 * @param other the state we don't want to be in
+	 * @return the new state (or other if we timed out or were interrupted)
+	 */
+	private synchronized InterruptState waitForStateChange(InterruptState other) {
 				try {
+			while (aborting == other) {
+				wait();
+			}
+		} catch (InterruptedException e) {
+			// TODO: figure out exactly when this can happen, and what to do
+		}
+		return aborting;
+	}
+
+	private synchronized InterruptState changeState(InterruptState newState) {
+		Log.i(TAG, "Changing " + aborting.toString() + " -> " + newState.toString());
+		InterruptState oldState = aborting;
+		aborting = newState;
+		notifyAll();
+		return oldState;
+	}
+
+	private void mainLoop(ProfileStats timers) {
 					while (true) {
-//								System.err.print("pc = ");
-//								System.err.println(Integer.toString(pc, 16));
+			// reset interrupted status
+			if (Thread.interrupted()) {
+				// TODO: restore pc if we paused
+				Log.w(TAG, "Was interrupted - but not any more...");
+			}
+			InterruptState s = waitForStateChange(InterruptState.PAUSED);
+			switch (s) {
+			case ABORTING:
+				changeState(InterruptState.FINISHED);
+				return;
+			case PAUSING:
+				changeState(InterruptState.PAUSED);
+				break;
+			case RESUMING:
+				changeState(InterruptState.RUNNING);
+				// ** fall through **
+			case RUNNING:
+				try {
+					// TODO handle PAUSING: save previous pc
+					long t1 = System.nanoTime();
 								zi.decode_instruction();
 								zi.execute();
+					long t2 = System.nanoTime();
+					timers.add(zi.opnum, 0.000001 * (t2 - t1));
+				} catch (ZMachineInterrupted zi) {
+					// we were interrupted, probably for pause or abort
+					// so absorb the exception
+				}
+				break;
+			case FINISHED:
+				// happens on a normal op_quit cycle
+				return;
+			case PAUSED:
+				// Should not happen. Recoverable bug.
+				Log.e(TAG, "State should never go PAUSED -> PAUSED");
+				break;
+			default:
+				throw new ZMachineException(pc, "Unexpected state: " + s);
+			}
 					}
 				}
-				catch (ArrayIndexOutOfBoundsException booga) {
-					System.err.print("pc = ");
-					System.err.println(Integer.toString(pc, 16));
 					
-					throw booga;
+	private void runZM()
+	{
+		Log.i(TAG, "runZM() starting");
+		// Track timing for each opcode named above
+		String[] opnames = getOpnames();
+		ProfileStats timers = new ProfileStats(opnames.length);
+		try {
+			mainLoop(timers);
+			timers.dump("opcode", opnames);
+			Log.i(TAG, "runZM() finishing without error");
+			screen.onZmFinished(null);
+		}
+		catch (ZMachineException e) {
+			changeState(InterruptState.FINISHED);
+			Log.e(TAG, "runZM() finishing with ZM exception", e);
+			screen.onZmFinished(e);
+		}
+		catch (RuntimeException e) {
+			changeState(InterruptState.FINISHED);
+			Log.e(TAG, "runZM() finishing with runtime exception", e);
+			screen.onZmFinished(new ZMachineException(pc, e));
+		}
+	}
+
+	public synchronized void abort() {
+		changeState(InterruptState.ABORTING);
+		thread.interrupt();  // cancel key input
+		pc = -1;
 				}
-				catch (ClassCastException booga) {
-					System.err.print("pc = ");
-					System.err.println(Integer.toString(pc, 16));
 					
-					throw booga;
+	public synchronized void quit() {
+		changeState(InterruptState.FINISHED);
 				}
+
+	public synchronized boolean pauseZM() {
+		if (aborting != InterruptState.RUNNING)
+			return false;
+		changeState(InterruptState.PAUSING);
+		thread.interrupt();  // cancel key input
+		// Block until the thread picks up the change
+		return (InterruptState.PAUSED == waitForStateChange(InterruptState.PAUSING));
+	}
+
+	public synchronized boolean resumeZM() {
+		if (aborting != InterruptState.PAUSED)
+			return false;
+		changeState(InterruptState.RESUMING);
+		// Block until the thread picks up the change
+		return (InterruptState.RUNNING == waitForStateChange(InterruptState.RESUMING));
 	}
 
 	void calculate_checksum() {
@@ -371,8 +533,7 @@
 	}
 
 	public void fatal(String s) {
-				System.err.println(s + " @ $" + Integer.toString(pc,16));
-				System.exit(-1);
+		throw new ZMachineException(pc, s);
 	}
 
 	public short get_variable(short varnum) {
@@ -421,7 +582,6 @@
 	}
 	
 	public short get_operand(int optype) {
-				short operand;
 				switch (optype) {
 				case OP_SMALL:
 					return (short)(get_code_byte() & 0xFF);
@@ -432,7 +592,184 @@
 					return get_variable(get_code_byte());
 				}
 				/* crash */
+		fatal("Invalid operand type " + optype);
 				return -1;
 	}
 
+	static class ProfileStats {
+		double[] count;
+		double[] sum_val;
+		double[] sum_val2;
+		final int limit;
+
+		ProfileStats(int limit) {
+			this.limit = limit;
+			count = new double[limit + 1];
+			sum_val = new double[limit + 1];
+			sum_val2 = new double[limit + 1];
+		}
+
+		public void add(int stat, double val) {
+			if (stat < 0 || stat >= limit)
+				stat = limit;
+			count[stat] += 1;
+			sum_val[stat] += val;
+			sum_val2[stat] += val * val;
+		}
+
+		public void dump(String label, String[] names) {
+			StringBuilder sb = new StringBuilder(",");
+			sb.append(label);
+			sb.append(",");
+			int start = sb.length();
+			sb.append("item,name,count,sum,mean,sd");
+			// This format makes it easy to pull data out of 'adb logcat'
+			// and load into a spreadsheet as CSV data
+			for (int i = 0; i <= limit; i++) {
+				if (count[i] == 0)
+					continue;
+				sb.delete(start, sb.length());
+				if (i < limit)
+					sb.append(i);
+				else
+					sb.append("other");
+				sb.append(",");
+				if (names != null)
+					sb.append(names[i]);
+				sb.append(",");
+				sb.append(count[i]);
+				sb.append(",");
+				sb.append(sum_val[i]);
+				sb.append(",");
+				sb.append(mean(sum_val[i], count[i]));
+				sb.append(",");
+				sb.append(sd(sum_val2[i], sum_val[i], count[i]));
+				Log.i("ProfileStats", sb.toString());
+			}
+		}
+
+		static double mean(double sum, double count) {
+			if (count <= 0.0)
+				return 0.0;
+			return sum / count;
+		}
+
+		static double sd(double sum2, double sum, double count) {
+			if (count <= 0.0)
+				return 0.0;
+			return Math.sqrt((sum * sum) - sum2) / (count * count);
+		}
+	}
+
+	public class CircularList<T extends Object> {
+		private static final long serialVersionUID = -4894945721696387127L;
+		private final int limit;
+		private final LinkedList<T> contents;
+
+		CircularList(int limit) {
+			this.limit = limit;
+			contents = new LinkedList<T>();
+		}
+
+		public void add(T object) {
+			contents.addLast(object);
+			while (contents.size() > limit)
+				contents.removeFirst();
+		}
+		
+		public T[] toArray(T[] t) {
+			return contents.toArray(t);
+		}
+		
+		public void clear() {
+			contents.clear();
+		}
+	}
+
+	public void logPrintedString() {
+		if (!zmLog)
+			return;
+		StringBuffer sb = new StringBuffer(Integer.toHexString(pc))
+		.append("# ");
+		if (zmLogString.length() > 80) {
+			// Trim middle so whole length is 80
+			zmLogString.replace(37, zmLogString.length() - 37, " .... ");
+		}
+		sb.append(zmLogString);
+		zmLogString.setLength(0);
+		String s = sb.toString();
+		zmLogEntries.add(s);
+		// Log.v(ZMLOG, s);
+	}
+
+	public void logInstruction(ZInstruction zi) {
+		if (!zmLog)
+			return;
+		String opname = getOpnames()[zi.opnum];
+		if (opname.charAt(0) != 'c' && opname.charAt(0) != 'r')
+			return;
+		StringBuffer sb = new StringBuffer();
+		for (int i = zstack.size(); i > 0; --i)
+			sb.append(' ');
+		sb.append(Integer.toHexString(pc))
+		.append(": ")
+		.append(opname);
+		switch(zi.opnum) {
+		case ZInstruction.OP_PRINT_CHAR:
+			if (zi.operands[0] >= 32 && zi.operands[0] <= 127) {
+				sb.append(" \'")
+				.append((char) zi.operands[0])
+				.append('\'');
+				break;
+			}
+			// ** fall through **
+		default:
+			for (int i = 0; i < zi.count; i++) {
+				int o = zi.operands[i];
+				if (o < 0) {
+					sb.append(" -")
+					.append(Integer.toHexString(-o));
+				} else {
+					sb.append(' ')
+					.append(Integer.toHexString(o));
+				}
+			}
+			if (zi.isbranch()) {
+				int o = zi.branchoffset;
+				if (o < 0) {
+					sb.append(" b=-")
+					.append(Integer.toHexString(-o));
+				} else {
+					sb.append(" b=")
+					.append(Integer.toHexString(o));
+				}
+			}
+			if (zi.isstore()) {
+				int o = zi.storevar;
+				if (o < 0) {
+					sb.append(" s=-")
+					.append(Integer.toHexString(-o));
+				} else {
+					sb.append(" s=")
+					.append(Integer.toHexString(o));
+				}
+			}
+		}
+		String s = sb.toString();
+		zmLogEntries.add(s);
+		// Log.v(ZMLOG, s);
+	}
+
+	/**
+	 * Is the zmachine in a state where it could execute instructions soon?
+	 */
+	public synchronized boolean isRunning() {
+		switch (aborting) {
+		case ABORTING:
+		case FINISHED:
+			return false;
+		default:
+			return true;
+		}
+	}
 }
diff -urbw zplet-20060707/src/russotto/zplet/zmachine/ZObjectTree.java twisty/src/russotto/zplet/zmachine/ZObjectTree.java
--- zplet-20060707/src/russotto/zplet/zmachine/ZObjectTree.java	2001-02-26 11:18:16.000000000 -0800
+++ twisty/src/russotto/zplet/zmachine/ZObjectTree.java	2007-11-20 10:40:08.000000000 -0800
@@ -1,3 +1,6 @@
+/* This file was modified from the original source, please see the
+ * zplet.patch file included at the top of this source tree.
+ */
 /* Zplet, a Z-Machine interpreter in Java */
 /* Copyright 1996,2001 Matthew T. Russotto */
 /* As of 23 February 2001, this code is open source and covered by the */
@@ -5,11 +8,6 @@
 
 package russotto.zplet.zmachine;
 
-import java.util.*;
-import java.awt.*;
-import java.net.*;
-import java.io.*;
-import java.applet.Applet;
 
 public abstract class ZObjectTree {
 	protected ZMachine zm;
diff -urbw zplet-20060707/src/russotto/zplet/zmachine/state/ZSFrame.java twisty/src/russotto/zplet/zmachine/state/ZSFrame.java
--- zplet-20060707/src/russotto/zplet/zmachine/state/ZSFrame.java	2001-02-26 11:18:16.000000000 -0800
+++ twisty/src/russotto/zplet/zmachine/state/ZSFrame.java	2007-11-20 10:40:06.000000000 -0800
@@ -5,64 +5,40 @@
 
 package russotto.zplet.zmachine.state;
 
-import java.util.*;
-import java.awt.*;
-import java.net.*;
-import java.io.*;
-import java.applet.Applet;
-import russotto.iff.*;
-
-class ZSFrame extends Frame {
-	FileDialog fd;
+class ZSFrame {
+  // FileDialog fd;
 	boolean ran=false;
-	int boxtype = FileDialog.SAVE;
+
+  // int boxtype = FileDialog.SAVE;
 	Thread blockedthread = null;
 
-	public ZSFrame()
-	{
-		super();
+  public ZSFrame() {
+    // super();
 	}
 
-	public ZSFrame(String title)
-	{
-		super(title);
+  public ZSFrame(String title) {
+    // super(title);
 	}
 
-	public ZSFrame(String title, int boxtype)
-	{
+  public ZSFrame(String title, int boxtype) {
 		this(title);
-		this.boxtype = boxtype;
-	}
-
-	public boolean handleEvent(Event evt)
-	{
-		if (!ran) {
-			fd = new FileDialog(this, "Save game as...", boxtype);
-			fd.show();
-		}
-		ran = true;
-		if (blockedthread != null)
-			blockedthread.resume();
-		return super.handleEvent(evt);
+    // this.boxtype = boxtype;
 	}
 
-	public String getFile() {
-		if (!ran) {
-			blockedthread = Thread.currentThread();
-			blockedthread.suspend();
-			/* race conditions galore */
-		}
-		return fd.getFile();
-	}
-
-	public String getDirectory() {
-		if (!ran) {
-			blockedthread = Thread.currentThread();
-			blockedthread.suspend();
-			/* race conditions galore */
-		}
-		return fd.getDirectory();
-	}
+  /*
+         * MM TODO public boolean handleEvent(Event evt) { if (!ran) { fd = new
+         * FileDialog(this, "Save game as...", boxtype); fd.show(); } ran =
+         * true; if (blockedthread != null) blockedthread.resume(); return
+         * super.handleEvent(evt); }
+         * 
+         * public String getFile() { if (!ran) { blockedthread =
+         * Thread.currentThread(); blockedthread.suspend(); // race conditions
+         * galore } return fd.getFile(); }
+         * 
+         * public String getDirectory() { if (!ran) { blockedthread =
+         * Thread.currentThread(); blockedthread.suspend(); // race conditions
+         * galore } return fd.getDirectory(); }
+         */
 }
 
 /** ZState holds the state-of-play for the Z machine */
diff -urbw zplet-20060707/src/russotto/zplet/zmachine/state/ZState.java twisty/src/russotto/zplet/zmachine/state/ZState.java
--- zplet-20060707/src/russotto/zplet/zmachine/state/ZState.java	2001-02-26 11:18:16.000000000 -0800
+++ twisty/src/russotto/zplet/zmachine/state/ZState.java	2008-10-20 10:37:05.000000000 -0700
@@ -1,3 +1,6 @@
+/* This file was modified from the original source, please see the
+ * zplet.patch file included at the top of this source tree.
+ */
 /* Zplet, a Z-Machine interpreter in Java */
 /* Copyright 1996,2001 Matthew T. Russotto */
 /* As of 23 February 2001, this code is open source and covered by the */
@@ -5,32 +8,55 @@
 
 package russotto.zplet.zmachine.state;
 
-import java.util.*;
-import java.awt.*;
-import java.net.*;
-import java.io.*;
-import java.applet.Applet;
-import russotto.iff.*;
-import russotto.zplet.zmachine.ZMachine;
-import russotto.zplet.zmachine.ZHeader;
+import java.io.IOException;
+import java.util.Enumeration;
+import java.util.Stack;
+
+import android.util.Log;
+import android.os.Handler;
+import android.os.Message;
+
+import com.google.twisty.Twisty;
+import com.google.twisty.TwistyMessage;
+import com.google.twisty.io.SeekableByteArrayInputStream;
+import com.google.twisty.io.SeekableByteArrayOutputStream;
+import com.google.twisty.zplet.ZMachineInterrupted;
+
+import russotto.iff.IFFChunkInfo;
+import russotto.iff.IFFChunkNotFoundException;
+import russotto.iff.IFFInputFile;
+import russotto.iff.IFFOutputFile;
+import russotto.zplet.screenmodel.ZScreen;
 import russotto.zplet.zmachine.ZFrameBound;
+import russotto.zplet.zmachine.ZHeader;
 import russotto.zplet.zmachine.ZInstruction;
-import russotto.zplet.zmachine.zmachine5.ZMachine5;
+import russotto.zplet.zmachine.ZMachine;
 import russotto.zplet.zmachine.zmachine5.ZInstruction5;
+import russotto.zplet.zmachine.zmachine5.ZMachine5;
 
 public class ZState {
 	final static short QUETZAL_PROCEDURE = 0x10;
 
+	private static final String TAG = "ZState";
+
 	ZMachine zm;
-	Stack zstack;
+	Stack<Object> zstack;
 	public ZHeader header;
 	int pc;
 	byte dynamic[];
 	short locals[];
 	short argcount;
+	String current_savefile_name;
 	
 	public ZState(ZMachine zm) {
 		this.zm = zm;
+		this.current_savefile_name = null;
+	}
+
+	private static Stack<Object> clonestack(Stack<Object> s) {
+		Stack<Object> r = new Stack<Object>();
+		r.addAll(s);
+		return r;
 	}
 
 	public void save_current() {
@@ -40,7 +66,7 @@
 		dyn_size = header.static_base();
 /* clones the stack but not the Integers within.  Fortunately they are
 immutable.	But the arrays aren't, so don't mess with them */
-		zstack = (Stack)zm.zstack.clone();
+		zstack = clonestack(zm.zstack);
 		dynamic = new byte[dyn_size];
 		System.arraycopy(zm.memory_image, 0, dynamic, 0, dyn_size);
 		locals = new short[zm.locals.length];
@@ -55,49 +81,58 @@
 		System.arraycopy(dynamic, 0, zm.memory_image, 0, dynamic.length);
 		zm.locals = new short[locals.length];
 		System.arraycopy(locals, 0, zm.locals, 0, locals.length);
-		zm.zstack = (Stack)zstack.clone();
+		zm.zstack = clonestack(zstack);
 		zm.pc = pc;
 		if (header.version() > 3)
 			((ZMachine5)zm).argcount = argcount;
 	}
 
-	String get_save_file_name(Frame parentframe)
+	String get_save_file_name(ZScreen parent)
 	{
-		FileDialog fd;
-		String returnval;
+		TwistyMessage msg = new TwistyMessage();
+		msg.path = current_savefile_name;
+		Handler dialog_handler = parent.getDialogHandler();		
 
+		// Tell Twisty to prompt the user for a filename, then block.
+		synchronized (parent) {
 		try {
-			fd = new FileDialog(parentframe, "Save game as...", FileDialog.SAVE);
-			fd.show();
-			Toolkit.getDefaultToolkit().sync();
-			returnval = fd.getDirectory() + fd.getFile();
+				Message.obtain(dialog_handler, Twisty.PROMPT_FOR_SAVEFILE, msg).sendToTarget();
+				parent.wait();
 		}
-		catch (AWTError awte) {
-			returnval = "";
+			catch (InterruptedException e) {
+				throw new ZMachineInterrupted();
 		}
-		return returnval;
 	}
 	
-	public String get_restore_file_name(Frame parentframe)
+		// Twisty should have modified our TwistyMessage object, and 
+		// then called notify() to wake us up.
+		current_savefile_name = msg.path;
+		return current_savefile_name;
+	}
+	
+	public String get_restore_file_name(ZScreen parent)
 	{
-		FileDialog fd;
-		String returnval;
+		TwistyMessage msg = new TwistyMessage();
+		Handler dialog_handler = parent.getDialogHandler();		
 
+		// Tell Twisty to prompt the user for a filename, then block.
+		synchronized (parent) {
 		try {
-			fd = new FileDialog(parentframe, "Restore game from...", FileDialog.LOAD);
-			fd.show();
-			Toolkit.getDefaultToolkit().sync();
-			returnval = fd.getDirectory() + fd.getFile();
+				Message.obtain(dialog_handler, Twisty.PROMPT_FOR_RESTOREFILE, msg).sendToTarget();
+				parent.wait();
 		}
-		catch (AWTError awte) {
-			returnval = "";
+			catch (InterruptedException e) {
+				throw new ZMachineInterrupted();
 		}
-		return returnval;
 	}
 
-	public boolean restore_from_disk(Frame parentframe) {
-		String fname;
-		IFFInputFile infile = null;
+		// Twisty should have modified our TwistyMessage object, and 
+		// then called notify() to wake us up.
+		current_savefile_name = msg.path;
+		return current_savefile_name;
+	}
+
+	public boolean restore_from_iff(IFFInputFile infile) {
 		IFFChunkInfo chunkinfo;
 		String formtype;
 		boolean returnvalue = false;
@@ -123,9 +158,7 @@
 		lastargmask = 0;
 		
 		version = zm.header.version();
-		fname = get_restore_file_name(parentframe);
 		try {
-			infile = new IFFInputFile(fname);
 			formtype = infile.readFORM();
 			if (formtype.equals("IFZS")) {
 				/* find the IFHD */
@@ -198,7 +231,7 @@
 				infile.seek(ifhdend);
 				/* read the stacks */
 				chunkinfo = infile.skipToChunk("Stks");
-				zstack = new Stack();
+				zstack = new Stack<Object>();
 				
 				frameno = 0;
 				while (infile.getChunkPointer() < chunkinfo.chunklength) {
@@ -217,12 +250,12 @@
 					
 					if (frameno > 0) { /* no frame header for dummy frame */
 						if ((flags & QUETZAL_PROCEDURE) == QUETZAL_PROCEDURE) {
-							zstack.push(new ZFrameBound(false));
+							zstack.push(ZFrameBound.FALSE);
 							if (version > 3)
 								zstack.push(new Integer(ZInstruction5.OP_CALL_VN));  /* not entirely correct, but close enough */
 						}
 						else {
-							zstack.push(new ZFrameBound(true));
+							zstack.push(ZFrameBound.TRUE);
 							zstack.push(new Integer(resultvar));
 							if (version > 3)
 								zstack.push(new Integer(ZInstruction.OP_CALL_1S));  /* not entirely correct, but close enough */
@@ -270,7 +303,7 @@
 		
 		catch (IOException excpt)
 		{
-			System.err.println(excpt);
+			Log.e(TAG, "Restore failed", excpt);
 			try {
 				if (infile != null)
 					infile.close();
@@ -280,7 +313,7 @@
 		}
 		catch (IFFChunkNotFoundException cnfexcpt)
 		{
-			System.err.println(cnfexcpt);
+			Log.e(TAG, "Restore failed", cnfexcpt);
 			try {
 				if (infile != null)
 					infile.close();
@@ -290,7 +323,7 @@
 		}
 		catch (SecurityException sexcpt)
 		{
-			System.err.println(sexcpt);
+			Log.e(TAG, "Restore failed", sexcpt);
 			try {
 				if (infile != null)
 					infile.close();
@@ -313,6 +346,26 @@
 		return returnvalue;
 	}
 	
+	public boolean restore_from_disk(ZScreen parent) {
+		String fname;
+		
+		fname = get_restore_file_name(parent);
+		try {
+			return restore_from_iff(new IFFInputFile(fname));
+		} catch (IOException e) {
+			return false;
+		}
+	}
+
+	public boolean restore_from_mem(byte[] frozen_game) {
+		SeekableByteArrayInputStream is = new SeekableByteArrayInputStream(frozen_game);
+		try {
+			return restore_from_iff(new IFFInputFile(is));
+		} catch (IOException e) {
+			return false;
+		}
+	}
+
 	private void write_cmem_chunk(IFFOutputFile outfile) throws IOException {
 		int i;
 		int runsize;
@@ -340,12 +393,35 @@
 		outfile.closeChunk();
 	}
 	
-	public boolean disk_save(Frame parentframe, int save_pc) {
-		String fname;
-		Enumeration e,f;
+	public boolean disk_save(ZScreen parent, int save_pc) {
+		String fname = get_save_file_name(parent);
+		if (fname.equals("") || fname.equals("nullnull"))
+			return false;  // user didn't pick a file
+		return disk_save(fname, save_pc);
+	}
+
+	public boolean disk_save(String fname, int save_pc) {
+		try {
+			return disk_save(new IFFOutputFile(fname, "IFZS"), save_pc);
+		} catch (IOException e) {
+			return false;
+		}
+	}
+
+	public byte[] mem_save(int save_pc) {
+		SeekableByteArrayOutputStream baos = new SeekableByteArrayOutputStream();
+		try {
+			if (disk_save(new IFFOutputFile(baos, "IFZS"), save_pc))
+				return baos.toByteArray();
+		} catch (IOException e) {
+		}
+		return null;
+	}
+
+	public boolean disk_save(IFFOutputFile outfile, int save_pc) {
+		Enumeration<Object> e,f;
 		Object el, el2;
 		int i;
-		IFFOutputFile outfile = null;
 		boolean framestore;
 		short storevar;
 		short argcount;
@@ -359,21 +435,13 @@
 		boolean returnvalue = false;
 
 		try {
-			fname = get_save_file_name(parentframe);
-			if (fname.equals("") || fname.equals("nullnull"))
-				throw new java.io.IOException("No file picked"); /* user didn't pick a file */
-				
-			outfile = new IFFOutputFile(fname, "IFZS");
 			outfile.openChunk("IFhd");
-			outfile.write(zm.memory_image, header.RELEASE, 2);
-			outfile.write(zm.memory_image, header.SERIAL_NUMBER, 6);
-			outfile.write(zm.memory_image, header.FILE_CHECKSUM, 2);
+			outfile.write(zm.memory_image, ZHeader.RELEASE, 2);
+			outfile.write(zm.memory_image, ZHeader.SERIAL_NUMBER, 6);
+			outfile.write(zm.memory_image, ZHeader.FILE_CHECKSUM, 2);
 			outfile.writeByte((save_pc&0xFF0000) >>> 16);
 			outfile.writeShort(save_pc&0xFFFF);
 			outfile.closeChunk();
-//			outfile.openChunk("UMem");
-//			outfile.write(zm.memory_image, 0, zm.header.static_base());
-//			outfile.closeChunk();
 			write_cmem_chunk(outfile);
 			outfile.openChunk("Stks");
 			version = zm.header.version();
diff -urbw zplet-20060707/src/russotto/zplet/zmachine/state/ZStateHeader.java twisty/src/russotto/zplet/zmachine/state/ZStateHeader.java
--- zplet-20060707/src/russotto/zplet/zmachine/state/ZStateHeader.java	2001-02-26 11:18:16.000000000 -0800
+++ twisty/src/russotto/zplet/zmachine/state/ZStateHeader.java	2007-11-20 10:40:06.000000000 -0800
@@ -1,3 +1,6 @@
+/* This file was modified from the original source, please see the
+ * zplet.patch file included at the top of this source tree.
+ */
 /* Zplet, a Z-Machine interpreter in Java */
 /* Copyright 1996,2001 Matthew T. Russotto */
 /* As of 23 February 2001, this code is open source and covered by the */
@@ -5,12 +8,6 @@
 
 package russotto.zplet.zmachine.state;
 
-import java.util.*;
-import java.awt.*;
-import java.net.*;
-import java.io.*;
-import java.applet.Applet;
-import russotto.iff.*;
 import russotto.zplet.zmachine.ZHeader;
 
 class ZStateHeader extends ZHeader
diff -urbw zplet-20060707/src/russotto/zplet/zmachine/zmachine3/ZDictionary3.java twisty/src/russotto/zplet/zmachine/zmachine3/ZDictionary3.java
--- zplet-20060707/src/russotto/zplet/zmachine/zmachine3/ZDictionary3.java	2001-02-26 11:18:16.000000000 -0800
+++ twisty/src/russotto/zplet/zmachine/zmachine3/ZDictionary3.java	2007-11-20 10:40:06.000000000 -0800
@@ -1,3 +1,6 @@
+/* This file was modified from the original source, please see the
+ * zplet.patch file included at the top of this source tree.
+ */
 /* Zplet, a Z-Machine interpreter in Java */
 /* Copyright 1996,2001 Matthew T. Russotto */
 /* As of 23 February 2001, this code is open source and covered by the */
@@ -5,11 +8,6 @@
 
 package russotto.zplet.zmachine.zmachine3;
 
-import java.util.*;
-import java.awt.*;
-import java.net.*;
-import java.io.*;
-import java.applet.Applet;
 import russotto.zplet.zmachine.ZDictionary;
 import russotto.zplet.zmachine.ZMachine;
 
@@ -107,7 +105,6 @@
 	public void tokenise(int textloc, int textlength, int parseloc) {
 		int wordloc, wordlength;
 		int textleft = textlength;
-		int dictloc;
 		char ch;
 		boolean pbfull;
 
diff -urbw zplet-20060707/src/russotto/zplet/zmachine/zmachine3/ZHeader3.java twisty/src/russotto/zplet/zmachine/zmachine3/ZHeader3.java
--- zplet-20060707/src/russotto/zplet/zmachine/zmachine3/ZHeader3.java	2001-02-26 11:18:16.000000000 -0800
+++ twisty/src/russotto/zplet/zmachine/zmachine3/ZHeader3.java	2007-11-20 10:40:06.000000000 -0800
@@ -1,3 +1,6 @@
+/* This file was modified from the original source, please see the
+ * zplet.patch file included at the top of this source tree.
+ */
 /* Zplet, a Z-Machine interpreter in Java */
 /* Copyright 1996,2001 Matthew T. Russotto */
 /* As of 23 February 2001, this code is open source and covered by the */
@@ -5,11 +8,6 @@
 
 package russotto.zplet.zmachine.zmachine3;
 
-import java.util.*;
-import java.awt.*;
-import java.net.*;
-import java.io.*;
-import java.applet.Applet;
 import russotto.zplet.zmachine.ZHeader;
 
 class ZHeader3 extends ZHeader
diff -urbw zplet-20060707/src/russotto/zplet/zmachine/zmachine3/ZMachine3.java twisty/src/russotto/zplet/zmachine/zmachine3/ZMachine3.java
--- zplet-20060707/src/russotto/zplet/zmachine/zmachine3/ZMachine3.java	2001-02-26 11:18:16.000000000 -0800
+++ twisty/src/russotto/zplet/zmachine/zmachine3/ZMachine3.java	2008-10-19 19:53:44.000000000 -0700
@@ -1,3 +1,6 @@
+/* This file was modified from the original source, please see the
+ * zplet.patch file included at the top of this source tree.
+ */
 /* Zplet, a Z-Machine interpreter in Java */
 /* Copyright 1996,2001 Matthew T. Russotto */
 /* As of 23 February 2001, this code is open source and covered by the */
@@ -5,18 +8,41 @@
 
 package russotto.zplet.zmachine.zmachine3;
 
-import java.util.*;
-import java.awt.*;
-import java.net.*;
-import java.io.*;
-import java.applet.Applet;
-import russotto.zplet.zmachine.*;
 import russotto.zplet.screenmodel.ZScreen;
 import russotto.zplet.screenmodel.ZStatus;
 import russotto.zplet.screenmodel.ZWindow;
+import russotto.zplet.zmachine.ZInstruction;
+import russotto.zplet.zmachine.ZMachine;
 
 public class ZMachine3 extends ZMachine {
 
+	static final String[] opnames3 = new String[] {
+		"", "je", "jl", "jg", "dec_chk", "inc_chk", "jin", "test", "or", "and",
+		"test_attr", "set_attr", "clear_attr", "store", "insert_obj", "loadw",
+		"loadb", "get_prop", "get_prop_addr", "get_next_prop", "add", "sub",
+		"mul", "div", "mod", "call_2s", "call_2n", "", "", "",
+		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
+		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
+		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
+		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
+		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
+		"", "", "", "", "", "", "", "",
+		"jz", "get_sibling", "get_child", "get_parent", "get_prop_len", "inc",
+		"dec", "print_addr", "call_1s", "remove_obj", "print_obj", "ret",
+		"jump", "print_paddr", "load", "not", "", "", "", "", "", "", "", "",
+		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
+		"", "", "", "", "", "",
+		"rtrue", "rfalse", "print", "print_ret", "nop", "save", "restore",
+		"restart", "ret_popped", "pop/catch", "quit", "new_line",
+		"show_status", "verify", "", "", "", "", "", "", "",
+		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
+		"", "", "", "", "", "", "", "", "",
+		"call", "storew", "storeb", "put_prop", "sread", "print_char",
+		"print_num", "random", "push", "pull", "split_window", "set_window",
+		"call_vs2", "erase_window", "erase_line", "set_cursor", "get_cursor",
+		"set_text_style", "buffer_mode", "output_stream", "input_stream"
+	};
+	
 	public ZMachine3(ZScreen screen, ZStatus status_line, byte [] memory_image) {
 		super(screen, status_line, memory_image);
 
@@ -25,8 +51,8 @@
 		zd = new ZDictionary3(this);
 		globals = header.global_table();
 		window = new ZWindow[2];
-		window[0] = new ZWindow(screen);
-		window[1] = new ZWindow(screen);
+		window[0] = new ZWindow(screen, 0);
+		window[1] = new ZWindow(screen, 1);
 		window[1].set_transcripting(false);
 		current_window = window[0];
 		zi = new ZInstruction(this);
@@ -64,9 +90,9 @@
 
 		window[0].moveto(0,0);
 		window[1].moveto(0,0);
-		window[0].resize(screen.getchars(),screen.getlines());
+		window[0].resize(screen.getchars(), -1);
 		window[1].resize(0,0);
-		window[0].movecursor(0,window[0].getHeight()-1);
+		window[0].movecursor(-1);
 	}
 
 	public void set_header_flags() { /* at start, restart, restore */
@@ -75,6 +101,11 @@
 		super.set_header_flags();
 		header.set_status_unavailable(false);
 		header.set_splitting_available(true);
-		header.set_variable_default(false);
+		header.set_variable_default(true);
+	}
+
+	@Override
+	public String[] getOpnames() {
+		return opnames3;
 	}
 }
diff -urbw zplet-20060707/src/russotto/zplet/zmachine/zmachine3/ZObjectTree3.java twisty/src/russotto/zplet/zmachine/zmachine3/ZObjectTree3.java
--- zplet-20060707/src/russotto/zplet/zmachine/zmachine3/ZObjectTree3.java	2001-02-26 11:18:16.000000000 -0800
+++ twisty/src/russotto/zplet/zmachine/zmachine3/ZObjectTree3.java	2007-11-20 10:40:06.000000000 -0800
@@ -1,3 +1,6 @@
+/* This file was modified from the original source, please see the
+ * zplet.patch file included at the top of this source tree.
+ */
 /* Zplet, a Z-Machine interpreter in Java */
 /* Copyright 1996,2001 Matthew T. Russotto */
 /* As of 23 February 2001, this code is open source and covered by the */
@@ -5,13 +8,8 @@
 
 package russotto.zplet.zmachine.zmachine3;
 
-import java.util.*;
-import java.awt.*;
-import java.net.*;
-import java.io.*;
-import java.applet.Applet;
-import russotto.zplet.zmachine.ZObjectTree;
 import russotto.zplet.zmachine.ZMachine;
+import russotto.zplet.zmachine.ZObjectTree;
 
 class ZObjectTree3 extends ZObjectTree
 {
diff -urbw zplet-20060707/src/russotto/zplet/zmachine/zmachine5/ZDictionary5.java twisty/src/russotto/zplet/zmachine/zmachine5/ZDictionary5.java
--- zplet-20060707/src/russotto/zplet/zmachine/zmachine5/ZDictionary5.java	2001-02-26 11:18:18.000000000 -0800
+++ twisty/src/russotto/zplet/zmachine/zmachine5/ZDictionary5.java	2007-11-20 10:40:07.000000000 -0800
@@ -1,3 +1,6 @@
+/* This file was modified from the original source, please see the
+ * zplet.patch file included at the top of this source tree.
+ */
 /* Zplet, a Z-Machine interpreter in Java */
 /* Copyright 1996,2001 Matthew T. Russotto */
 /* As of 23 February 2001, this code is open source and covered by the */
@@ -5,13 +8,8 @@
 
 package russotto.zplet.zmachine.zmachine5;
 
-import java.util.*;
-import java.awt.*;
-import java.net.*;
-import java.io.*;
-import java.applet.Applet;
-import russotto.zplet.zmachine.ZMachine;
 import russotto.zplet.zmachine.ZDictionary;
+import russotto.zplet.zmachine.ZMachine;
 
 public class ZDictionary5 extends ZDictionary{
 		ZMachine zm;
@@ -125,7 +123,6 @@
 		public void tokenise(int textloc, int textlength, int parseloc, boolean parseunknown) {
 				int wordloc, wordlength;
 				int textleft = textlength;
-				int dictloc;
 				char ch;
 				boolean pbfull;
 
diff -urbw zplet-20060707/src/russotto/zplet/zmachine/zmachine5/ZHeader5.java twisty/src/russotto/zplet/zmachine/zmachine5/ZHeader5.java
--- zplet-20060707/src/russotto/zplet/zmachine/zmachine5/ZHeader5.java	2001-02-26 11:18:18.000000000 -0800
+++ twisty/src/russotto/zplet/zmachine/zmachine5/ZHeader5.java	2007-11-20 10:40:07.000000000 -0800
@@ -1,3 +1,6 @@
+/* This file was modified from the original source, please see the
+ * zplet.patch file included at the top of this source tree.
+ */
 /* Zplet, a Z-Machine interpreter in Java */
 /* Copyright 1996,2001 Matthew T. Russotto */
 /* As of 23 February 2001, this code is open source and covered by the */
@@ -5,11 +8,6 @@
 
 package russotto.zplet.zmachine.zmachine5;
 
-import java.util.*;
-import java.awt.*;
-import java.net.*;
-import java.io.*;
-import java.applet.Applet;
 import russotto.zplet.zmachine.ZHeader;
 
 class ZHeader5 extends ZHeader
diff -urbw zplet-20060707/src/russotto/zplet/zmachine/zmachine5/ZInstruction5.java twisty/src/russotto/zplet/zmachine/zmachine5/ZInstruction5.java
--- zplet-20060707/src/russotto/zplet/zmachine/zmachine5/ZInstruction5.java	2001-02-26 11:18:18.000000000 -0800
+++ twisty/src/russotto/zplet/zmachine/zmachine5/ZInstruction5.java	2008-10-20 10:35:49.000000000 -0700
@@ -1,3 +1,6 @@
+/* This file was modified from the original source, please see the
+ * zplet.patch file included at the top of this source tree.
+ */
 /* Zplet, a Z-Machine interpreter in Java */
 /* Copyright 1996,2001 Matthew T. Russotto */
 /* As of 23 February 2001, this code is open source and covered by the */
@@ -5,15 +8,11 @@
 
 package russotto.zplet.zmachine.zmachine5;
 
-import java.util.*;
-import java.awt.*;
-import java.net.*;
-import java.io.*;
-import java.applet.Applet;
+import android.util.Log;
 import russotto.zplet.ZColor;
+import russotto.zplet.zmachine.ZFrameBound;
 import russotto.zplet.zmachine.ZInstruction;
 import russotto.zplet.zmachine.ZMachine;
-import russotto.zplet.zmachine.ZFrameBound;
 import russotto.zplet.zmachine.state.ZState;
 
 public class ZInstruction5 extends ZInstruction
@@ -60,6 +59,7 @@
 
 		final static int SCREEN_UNSPLIT = -1;
 		final static int SCREEN_NOUNSPLIT = -2;
+		private static final String TAG = "ZInstruction5";
 
 		protected short call_opnum;
 		protected boolean has_returned = false;
@@ -88,6 +88,7 @@
 		{
 				short result;
 				
+				zm.logInstruction(this);
 				switch (opnum) {
 				case OP_JE:
 						result = op_je();
@@ -459,7 +460,7 @@
 						   hey, it could happen */
 				}
 				else {
-						zm.zstack.push(new ZFrameBound(isstore()));
+						zm.zstack.push(ZFrameBound.get(isstore()));
 						if (isstore())
 							zm.zstack.push(new Integer(storevar));
 						zm.zstack.push(new Integer(opnum));
@@ -673,7 +674,7 @@
 
 		protected short op_buffer_mode()
 		{
-//				zm.window[LOWER_WINDOW].setbuffermode(operands[0] != 0);
+				zm.window[LOWER_WINDOW].setbuffermode(operands[0] != 0);
 				zm.window[LOWER_WINDOW].setwrapmode(operands[0] != 0);
 				return ZFALSE;
 		}
@@ -748,7 +749,7 @@
 				parseunknown = (count < 3) || (operands[3] == 0);
 					
 				if (userdict != 0)
-					System.err.println("tokenise opcode encountered (userdict)");
+					Log.e(TAG, "tokenise opcode encountered (userdict)");
 					
 				tbuf = operands[0]&0xFFFF;
 				tlen = zm.memory_image[tbuf+1];
@@ -852,7 +853,7 @@
 					ZState restore_state;
 					
 					restore_state = new ZState(zm);
-					if (restore_state.restore_from_disk(zm.screen.getFrame())) {
+					if (restore_state.restore_from_disk(zm.screen)) {
 						zm.restore(restore_state);
 						storevar = zm.get_code_byte();
 						return ZRESTORE_SUCCESS;
@@ -903,7 +904,7 @@
 				return result;
 		}
 
-		protected void setupbs() {
+		protected static void setupbs() {
 		/* Sets up store and branch instructions */
 				branch5[OP_JE] = true;
 				branch5[OP_JL] = true;
diff -urbw zplet-20060707/src/russotto/zplet/zmachine/zmachine5/ZMachine5.java twisty/src/russotto/zplet/zmachine/zmachine5/ZMachine5.java
--- zplet-20060707/src/russotto/zplet/zmachine/zmachine5/ZMachine5.java	2001-02-26 11:18:18.000000000 -0800
+++ twisty/src/russotto/zplet/zmachine/zmachine5/ZMachine5.java	2008-10-19 20:27:50.000000000 -0700
@@ -1,3 +1,6 @@
+/* This file was modified from the original source, please see the
+ * zplet.patch file included at the top of this source tree.
+ */
 /* Zplet, a Z-Machine interpreter in Java */
 /* Copyright 1996,2001 Matthew T. Russotto */
 /* As of 23 February 2001, this code is open source and covered by the */
@@ -5,17 +8,48 @@
 
 package russotto.zplet.zmachine.zmachine5;
 
-import java.util.*;
-import java.awt.*;
-import java.net.*;
-import java.io.*;
-import java.applet.Applet;
-import russotto.zplet.zmachine.*;
 import russotto.zplet.screenmodel.ZScreen;
 import russotto.zplet.screenmodel.ZWindow;
+import russotto.zplet.zmachine.ZMachine;
 import russotto.zplet.zmachine.state.ZState;
 
 public class ZMachine5 extends ZMachine {
+	static final String[] opnames5 = new String[] {
+		"", "je", "jl", "jg", "dec_chk", "inc_chk", "jin", "test", "or", "and",
+		"test_attr", "set_attr", "clear_attr", "store", "insert_obj", "loadw",
+		"loadb", "get_prop", "get_prop_addr", "get_next_prop", "add", "sub",
+		"mul", "div", "mod", "call_2s", "call_2n", "set_colour", "throw", "",
+		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
+		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
+		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
+		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
+		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
+		"", "", "", "", "", "", "", "",
+		"jz", "get_sibling", "get_child", "get_parent", "get_prop_len", "inc",
+		"dec", "print_addr", "call_1s", "remove_obj", "print_obj", "ret",
+		"jump", "print_paddr", "load", "call_1n", "", "", "", "", "", "", "",
+		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
+		"", "", "", "", "", "", "",
+		"rtrue", "rfalse", "print", "print_ret", "nop", "save", "restore",
+		"restart", "ret_popped", "catch", "quit", "new_line",
+		"show_status", "verify", "(extended)", "piracy", "", "", "", "", "",
+		"", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "",
+		"", "", "", "", "", "", "", "", "",
+		"call", "storew", "storeb", "put_prop", "aread", "print_char",
+		"print_num", "random", "push", "pull", "split_window", "set_window",
+		"call_vs2", "erase_window", "erase_line", "set_cursor", "get_cursor",
+		"set_text_style", "buffer_mode", "output_stream", "input_stream",
+		"sound_effect", "read_char", "scan_table", "not", "call_vn",
+		"call_vn2", "tokenise", "encode_text", "copy_table", "print_table",
+		"check_arg_count", "save", "restore", "log_shift", "art_shift",
+		"set_font", "draw_picture", "picture_data", "erase_picture",
+		"set_margins", "save_undo", "restore_undo", "print_unicode",
+		"check_unicode", "", "", "",
+		"move_window", "window_size", "window_style", "get_wind_prop",
+		"scroll_window", "pop_stack", "read_mouse", "mouse_window",
+		"push_stack", "put_wind_prop", "print_form", "make_menu",
+		"picture_table"
+	};
 
 		public short argcount;
 		ZState undo_state = null;
@@ -27,10 +61,10 @@
 				zd = new ZDictionary5(this);
 				globals = header.global_table();
 				window = new ZWindow[2];
-				window[0] = new ZWindow(screen);
-				 window[1] = new ZWindow(screen);
+				window[0] = new ZWindow(screen, 0);
+				window[1] = new ZWindow(screen, 1);
 				window[1].setscroll(false);
-//				window[1].setbuffermode(false);
+				window[1].setbuffermode(false);
 				window[1].setwrapmode(false);
 				window[1].set_transcripting(false);
 				current_window = window[0];
@@ -55,9 +89,9 @@
 
 				window[0].moveto(0,0);
 				window[1].moveto(0,0);
-				window[0].resize(screen.getchars(),screen.getlines());
+				window[0].resize(screen.getchars(), -1);
 				window[1].resize(0,0);
-				window[0].movecursor(0,window[0].getHeight()-1);
+				window[0].movecursor(-1);
 		}
 
 		public void set_header_flags() { /* at start, restart, restore */
@@ -110,5 +144,10 @@
 				undo_state.save_current();
 				return 1;
 		}
+
+		@Override
+		public String[] getOpnames() {
+			return opnames5;
+		}
 }
 
diff -urbw zplet-20060707/src/russotto/zplet/zmachine/zmachine5/ZMachine8.java twisty/src/russotto/zplet/zmachine/zmachine5/ZMachine8.java
--- zplet-20060707/src/russotto/zplet/zmachine/zmachine5/ZMachine8.java	2001-02-26 11:18:18.000000000 -0800
+++ twisty/src/russotto/zplet/zmachine/zmachine5/ZMachine8.java	2007-11-20 10:40:07.000000000 -0800
@@ -1,16 +1,12 @@
+/* This file was modified from the original source, please see the
+ * zplet.patch file included at the top of this source tree.
+ */
 /* Zplet, a Z-Machine interpreter in Java */
 /* Copyright 1996,2001 Matthew T. Russotto */
 /* As of 23 February 2001, this code is open source and covered by the */
 /* Artistic License, found within this package */
 
 package russotto.zplet.zmachine.zmachine5;
-import russotto.zplet.zmachine.*;
-
-import java.util.*;
-import java.awt.*;
-import java.net.*;
-import java.io.*;
-import java.applet.Applet;
 import russotto.zplet.screenmodel.ZScreen;
 
 public class ZMachine8 extends ZMachine5 {
diff -urbw zplet-20060707/src/russotto/zplet/zmachine/zmachine5/ZObjectTree5.java twisty/src/russotto/zplet/zmachine/zmachine5/ZObjectTree5.java
--- zplet-20060707/src/russotto/zplet/zmachine/zmachine5/ZObjectTree5.java	2001-02-26 11:18:18.000000000 -0800
+++ twisty/src/russotto/zplet/zmachine/zmachine5/ZObjectTree5.java	2007-11-20 10:40:07.000000000 -0800
@@ -1,3 +1,6 @@
+/* This file was modified from the original source, please see the
+ * zplet.patch file included at the top of this source tree.
+ */
 /* Zplet, a Z-Machine interpreter in Java */
 /* Copyright 1996,2001 Matthew T. Russotto */
 /* As of 23 February 2001, this code is open source and covered by the */
@@ -5,11 +8,6 @@
 
 package russotto.zplet.zmachine.zmachine5;
 
-import java.util.*;
-import java.awt.*;
-import java.net.*;
-import java.io.*;
-import java.applet.Applet;
 import russotto.zplet.zmachine.ZMachine;
 import russotto.zplet.zmachine.ZObjectTree;
 
@@ -148,8 +146,6 @@
 
 		public short prop_address(short object, short propnum) {
 				int entry_address = prop_entry_address(object, propnum);
-				int sizebyte;
-
 				if (entry_address == 0)
 						return 0;
 				if ((zm.memory_image[entry_address]&0x80) == 0x80)
